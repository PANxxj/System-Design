# High Level System Design (HLSD) - Basic Concepts

## Table of Contents
1. [Introduction to System Design](#introduction-to-system-design)
2. [Scalability Fundamentals](#scalability-fundamentals)
3. [Load Balancing](#load-balancing)
4. [Caching Strategies](#caching-strategies)
5. [Database Design](#database-design)
6. [Content Delivery Networks (CDN)](#content-delivery-networks-cdn)
7. [Basic System Architecture Patterns](#basic-system-architecture-patterns)
8. [API Design Principles](#api-design-principles)
9. [Security Basics](#security-basics)
10. [Monitoring and Logging](#monitoring-and-logging)

## Introduction to System Design

**High Level System Design** focuses on the architecture and infrastructure needed to build scalable, reliable, and efficient systems. It involves designing the overall structure, components, and their interactions.

### Key Concepts

- **Scalability**: Ability to handle increased load
- **Reliability**: System continues to work correctly even when failures occur
- **Availability**: System remains operational over time
- **Consistency**: All nodes see the same data simultaneously
- **Partition Tolerance**: System continues despite network partitions

### System Design Process

1. **Requirements Gathering**
   - Functional Requirements (What the system should do)
   - Non-functional Requirements (Performance, scalability, etc.)
   - Constraints and Assumptions

2. **Capacity Estimation**
   - Traffic estimates (QPS - Queries Per Second)
   - Storage requirements
   - Bandwidth requirements

3. **System Interface Definition**
   - API design
   - Database schema

4. **High-level Design**
   - Major components
   - Data flow
   - Technology choices

5. **Detailed Design**
   - Component internals
   - Algorithms and data structures
   - Optimization techniques

6. **Scale the Design**
   - Identify bottlenecks
   - Scale components
   - Add monitoring and alerting

### Example: URL Shortener Requirements

**Functional Requirements:**
- Shorten long URLs
- Redirect short URLs to original URLs
- Custom short URLs (optional)
- URL expiration

**Non-functional Requirements:**
- 100:1 read/write ratio
- 500 million URLs generated per month
- Service should be available 99.9% of the time
- Real-time redirection with minimal latency

**Capacity Estimation:**
```
Write QPS: 500M / (30 days * 24 hours * 3600 seconds) = ~200 URLs/second
Read QPS: 200 * 100 = 20,000 redirections/second

Storage (5 years): 500M * 12 months * 5 years = 30 billion URLs
Storage size: 30B * 500 bytes = 15 TB

Bandwidth:
- Incoming: 200 * 500 bytes = 100 KB/s
- Outgoing: 20K * 500 bytes = 10 MB/s
```

## Scalability Fundamentals

### Vertical vs Horizontal Scaling

#### Vertical Scaling (Scale Up)
- Add more power (CPU, RAM) to existing machines
- **Pros**: Simple, no code changes needed
- **Cons**: Hardware limits, single point of failure, expensive

#### Horizontal Scaling (Scale Out)
- Add more servers to the pool of resources
- **Pros**: No limit to scaling, cost-effective, fault tolerant
- **Cons**: Complex, requires load distribution

### Scalability Patterns

#### 1. Stateless Services
```
[Client] → [Load Balancer] → [Service 1]
                           → [Service 2]
                           → [Service 3]
```

- Services don't store client state
- Any server can handle any request
- Easy to scale horizontally

#### 2. Database Sharding
```
Users A-G → Shard 1
Users H-N → Shard 2
Users O-Z → Shard 3
```

#### 3. Read Replicas
```
[Application] → [Master DB] (Writes)
              → [Read Replica 1] (Reads)
              → [Read Replica 2] (Reads)
              → [Read Replica 3] (Reads)
```

## Load Balancing

Load balancers distribute incoming requests across multiple servers to ensure no single server becomes overwhelmed.

### Load Balancing Algorithms

#### 1. Round Robin
```python
class RoundRobinBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.current = 0

    def get_server(self):
        server = self.servers[self.current]
        self.current = (self.current + 1) % len(self.servers)
        return server
```

#### 2. Weighted Round Robin
```python
class WeightedRoundRobinBalancer:
    def __init__(self, servers_with_weights):
        # servers_with_weights = [("server1", 3), ("server2", 2), ("server3", 1)]
        self.servers = []
        for server, weight in servers_with_weights:
            self.servers.extend([server] * weight)
        self.current = 0

    def get_server(self):
        server = self.servers[self.current]
        self.current = (self.current + 1) % len(self.servers)
        return server
```

#### 3. Least Connections
```python
class LeastConnectionsBalancer:
    def __init__(self, servers):
        self.servers = {server: 0 for server in servers}

    def get_server(self):
        return min(self.servers, key=self.servers.get)

    def connection_started(self, server):
        self.servers[server] += 1

    def connection_ended(self, server):
        self.servers[server] -= 1
```

### Load Balancer Types

#### 1. Layer 4 (Transport Layer)
- Routes based on IP and port
- Faster, less resource intensive
- Cannot see application data

#### 2. Layer 7 (Application Layer)
- Routes based on application data (HTTP headers, URLs)
- More intelligent routing
- Higher overhead

### Load Balancer Placement

```
Internet → [DNS] → [Global Load Balancer]
                 → [Regional Load Balancer 1] → [Servers]
                 → [Regional Load Balancer 2] → [Servers]
```

## Caching Strategies

Caching stores frequently accessed data in fast storage for quick retrieval.

### Caching Levels

1. **Browser Cache** (Client-side)
2. **CDN Cache** (Edge servers)
3. **Application Cache** (In-memory)
4. **Database Cache** (Query results)

### Cache Patterns

#### 1. Cache-Aside (Lazy Loading)
```python
def get_user(user_id):
    # Try cache first
    user = cache.get(f"user:{user_id}")
    if user is None:
        # Cache miss - get from database
        user = database.get_user(user_id)
        # Store in cache
        cache.set(f"user:{user_id}", user, ttl=3600)
    return user

def update_user(user_id, user_data):
    # Update database
    database.update_user(user_id, user_data)
    # Invalidate cache
    cache.delete(f"user:{user_id}")
```

#### 2. Write-Through
```python
def update_user(user_id, user_data):
    # Update database
    database.update_user(user_id, user_data)
    # Update cache
    cache.set(f"user:{user_id}", user_data, ttl=3600)
```

#### 3. Write-Behind (Write-Back)
```python
def update_user(user_id, user_data):
    # Update cache immediately
    cache.set(f"user:{user_id}", user_data, ttl=3600)
    # Asynchronously update database
    async_queue.put(('update_user', user_id, user_data))
```

### Cache Eviction Policies

1. **LRU (Least Recently Used)**: Remove least recently accessed items
2. **LFU (Least Frequently Used)**: Remove least frequently accessed items
3. **FIFO (First In, First Out)**: Remove oldest items
4. **TTL (Time To Live)**: Remove items after expiration

### Distributed Caching

```
[App Server 1] → [Redis Cluster]
[App Server 2] → [Redis Cluster]
[App Server 3] → [Redis Cluster]

Redis Cluster:
- Master 1 (Slots 0-5460)
- Master 2 (Slots 5461-10922)
- Master 3 (Slots 10923-16383)
```

## Database Design

### SQL vs NoSQL

#### SQL Databases (RDBMS)
- **Examples**: MySQL, PostgreSQL, Oracle
- **ACID Properties**: Atomicity, Consistency, Isolation, Durability
- **Strong Consistency**: All reads receive the most recent write
- **Complex Queries**: JOINs, transactions, aggregations
- **Schema**: Fixed schema, normalized data

#### NoSQL Databases
- **Document**: MongoDB, CouchDB
- **Key-Value**: Redis, DynamoDB
- **Column-Family**: Cassandra, HBase
- **Graph**: Neo4j, Amazon Neptune

### CAP Theorem

You can only guarantee 2 out of 3:
- **Consistency**: All nodes see the same data simultaneously
- **Availability**: System remains operational
- **Partition Tolerance**: System continues despite network failures

```
CP Systems: Traditional RDBMS (sacrifice availability during partitions)
AP Systems: DNS, Web caching (sacrifice consistency for availability)
CA Systems: Single-node systems (not realistic in distributed systems)
```

### Database Scaling Patterns

#### 1. Master-Slave Replication
```
[Master DB] ← Writes
     ↓
[Slave 1] ← Reads
[Slave 2] ← Reads
[Slave 3] ← Reads
```

#### 2. Master-Master Replication
```
[Master 1] ↔ [Master 2]
    ↓           ↓
[Slaves]    [Slaves]
```

#### 3. Database Sharding

**Horizontal Partitioning**
```python
def get_shard(user_id):
    # Simple hash-based sharding
    shard_id = hash(user_id) % NUM_SHARDS
    return f"shard_{shard_id}"

# User data distributed across shards
# Users 1, 4, 7... → Shard 0
# Users 2, 5, 8... → Shard 1
# Users 3, 6, 9... → Shard 2
```

**Sharding Strategies:**

1. **Range-based**: Partition by value ranges
```python
# Users A-G → Shard 1
# Users H-N → Shard 2
# Users O-Z → Shard 3
```

2. **Hash-based**: Partition by hash function
```python
shard = hash(key) % num_shards
```

3. **Directory-based**: Lookup service maps keys to shards
```python
shard_directory = {
    "user_1": "shard_0",
    "user_2": "shard_1",
    # ...
}
```

### Database Types by Use Case

| Use Case | Database Type | Examples |
|----------|---------------|----------|
| Traditional OLTP | SQL | MySQL, PostgreSQL |
| Analytics/OLAP | Columnar | Redshift, BigQuery |
| Session Store | Key-Value | Redis, Memcached |
| User Profiles | Document | MongoDB, DynamoDB |
| Social Networks | Graph | Neo4j, Amazon Neptune |
| Time Series | Specialized | InfluxDB, TimescaleDB |
| Search | Search Engine | Elasticsearch, Solr |

## Content Delivery Networks (CDN)

CDNs are geographically distributed servers that cache content closer to users.

### How CDN Works

```
User in NYC → NYC Edge Server (if cached)
           → Origin Server (if not cached)

User in LA  → LA Edge Server (if cached)
           → Origin Server (if not cached)
```

### CDN Benefits

1. **Reduced Latency**: Content served from nearby servers
2. **Reduced Bandwidth**: Less traffic to origin servers
3. **DDoS Protection**: Distributed traffic absorption
4. **High Availability**: Multiple edge locations

### CDN Strategies

#### 1. Push CDN
- Content uploaded to CDN servers proactively
- Good for sites with slow-changing content
- Better control over what's cached

#### 2. Pull CDN
- Content cached on first request
- Good for sites with heavy traffic
- Less management overhead

### Cache Invalidation

```python
# Time-based expiration
cache_control: max-age=3600

# Version-based invalidation
file.css?v=1.2.3

# Hash-based invalidation
style.abc123.css
```

## Basic System Architecture Patterns

### 1. Monolithic Architecture

```
[Web UI] → [Business Logic] → [Database]
     ↕           ↕               ↕
[Single Deployable Unit]
```

**Pros:**
- Simple to develop and deploy
- Easy to test
- Good performance (local calls)

**Cons:**
- Single point of failure
- Difficult to scale individual components
- Technology lock-in

### 2. Service-Oriented Architecture (SOA)

```
[Client] → [Service Bus/ESB]
             ↓
[User Service] [Order Service] [Payment Service]
```

### 3. Microservices Architecture

```
[API Gateway] → [User Service] → [User DB]
              → [Order Service] → [Order DB]
              → [Payment Service] → [Payment DB]
```

**Pros:**
- Independent scaling
- Technology diversity
- Fault isolation
- Team autonomy

**Cons:**
- Increased complexity
- Network latency
- Data consistency challenges

### 4. Serverless Architecture

```
[Client] → [API Gateway] → [Lambda Functions]
                         → [Database]
                         → [Storage]
```

### Service Communication Patterns

#### 1. Synchronous Communication
```python
# REST API call
response = requests.get('http://user-service/users/123')
user = response.json()

# GraphQL
query = """
    query {
        user(id: "123") {
            name
            email
        }
    }
"""
```

#### 2. Asynchronous Communication
```python
# Message Queue
message_queue.publish('user.created', {
    'user_id': '123',
    'email': 'user@example.com'
})

# Event Bus
event_bus.publish(UserCreatedEvent(user_id='123'))
```

## API Design Principles

### REST API Design

#### HTTP Methods
- **GET**: Retrieve data (idempotent)
- **POST**: Create new resource
- **PUT**: Update entire resource (idempotent)
- **PATCH**: Partial update
- **DELETE**: Remove resource (idempotent)

#### Resource Naming
```
GET    /users              # Get all users
GET    /users/123          # Get specific user
POST   /users              # Create new user
PUT    /users/123          # Update user
DELETE /users/123          # Delete user

# Nested resources
GET    /users/123/orders   # Get user's orders
POST   /users/123/orders   # Create order for user
```

#### Response Codes
- **200 OK**: Successful GET, PUT, PATCH
- **201 Created**: Successful POST
- **204 No Content**: Successful DELETE
- **400 Bad Request**: Client error
- **401 Unauthorized**: Authentication required
- **403 Forbidden**: Access denied
- **404 Not Found**: Resource not found
- **500 Internal Server Error**: Server error

### API Versioning

#### 1. URL Versioning
```
/api/v1/users
/api/v2/users
```

#### 2. Header Versioning
```
GET /api/users
Accept: application/vnd.myapi.v1+json
```

#### 3. Query Parameter Versioning
```
/api/users?version=1
```

### Rate Limiting

```python
# Token Bucket Algorithm
class TokenBucket:
    def __init__(self, capacity, refill_rate):
        self.capacity = capacity
        self.tokens = capacity
        self.refill_rate = refill_rate
        self.last_refill = time.time()

    def consume(self, tokens=1):
        self._refill()
        if self.tokens >= tokens:
            self.tokens -= tokens
            return True
        return False

    def _refill(self):
        now = time.time()
        elapsed = now - self.last_refill
        tokens_to_add = elapsed * self.refill_rate
        self.tokens = min(self.capacity, self.tokens + tokens_to_add)
        self.last_refill = now
```

### API Documentation

```yaml
# OpenAPI/Swagger example
paths:
  /users:
    get:
      summary: List users
      parameters:
        - name: page
          in: query
          required: false
          schema:
            type: integer
      responses:
        '200':
          description: List of users
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
```

## Security Basics

### Authentication vs Authorization

- **Authentication**: Who you are (login)
- **Authorization**: What you can do (permissions)

### Authentication Methods

#### 1. Session-Based Authentication
```python
# Login process
def login(username, password):
    user = authenticate(username, password)
    if user:
        session_id = generate_session_id()
        session_store[session_id] = user
        return session_id
    return None

# Request validation
def validate_session(session_id):
    return session_store.get(session_id)
```

#### 2. Token-Based Authentication (JWT)
```python
import jwt

def create_token(user_id):
    payload = {
        'user_id': user_id,
        'exp': datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')

def validate_token(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload['user_id']
    except jwt.ExpiredSignatureError:
        return None
```

### Common Security Vulnerabilities

#### 1. SQL Injection
```python
# Bad - Vulnerable to SQL injection
query = f"SELECT * FROM users WHERE id = {user_id}"

# Good - Use parameterized queries
query = "SELECT * FROM users WHERE id = ?"
cursor.execute(query, (user_id,))
```

#### 2. Cross-Site Scripting (XSS)
```python
# Bad - Directly rendering user input
html = f"<div>Hello {user_name}</div>"

# Good - Escape user input
html = f"<div>Hello {html.escape(user_name)}</div>"
```

#### 3. Cross-Site Request Forgery (CSRF)
```python
# CSRF protection with tokens
def generate_csrf_token():
    return secrets.token_urlsafe(32)

def validate_csrf_token(token, session_token):
    return token == session_token
```

### HTTPS and TLS

```
Client ↔ [TLS Encryption] ↔ Server

1. Client Hello
2. Server Hello + Certificate
3. Key Exchange
4. Encrypted Communication
```

### Input Validation

```python
from marshmallow import Schema, fields, ValidationError

class UserSchema(Schema):
    email = fields.Email(required=True)
    age = fields.Integer(validate=lambda x: 0 < x < 150)
    name = fields.String(validate=lambda x: len(x) <= 100)

def validate_user_input(data):
    schema = UserSchema()
    try:
        result = schema.load(data)
        return result
    except ValidationError as err:
        return err.messages
```

## Monitoring and Logging

### Key Metrics

#### 1. Application Metrics
- **Response Time**: Time to process requests
- **Throughput**: Requests per second
- **Error Rate**: Percentage of failed requests
- **Apdex Score**: Application performance index

#### 2. Infrastructure Metrics
- **CPU Utilization**: Processor usage
- **Memory Usage**: RAM consumption
- **Disk I/O**: Read/write operations
- **Network I/O**: Bandwidth usage

#### 3. Business Metrics
- **Active Users**: Current user count
- **Conversion Rate**: Goal completion percentage
- **Revenue per User**: Business value metrics

### Logging Levels

```python
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

# Different log levels
logger.debug("Detailed information for debugging")
logger.info("General information about program execution")
logger.warning("Something unexpected happened")
logger.error("Error occurred, but program continues")
logger.critical("Critical error, program may abort")
```

### Structured Logging

```python
import json
import time

def structured_log(level, message, **kwargs):
    log_entry = {
        'timestamp': time.time(),
        'level': level,
        'message': message,
        'service': 'user-service',
        'version': '1.0.0',
        **kwargs
    }
    print(json.dumps(log_entry))

# Usage
structured_log('INFO', 'User logged in',
               user_id='123',
               ip_address='192.168.1.1',
               duration_ms=250)
```

### Alerting

```python
# Alert conditions
def check_error_rate():
    error_rate = get_error_rate_last_5_minutes()
    if error_rate > 0.05:  # 5% error rate
        send_alert("High error rate detected",
                   severity="CRITICAL",
                   current_rate=error_rate)

def check_response_time():
    avg_response_time = get_avg_response_time_last_5_minutes()
    if avg_response_time > 1000:  # 1 second
        send_alert("High response time detected",
                   severity="WARNING",
                   current_time=avg_response_time)
```

### Health Checks

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/health')
def health_check():
    checks = {
        'database': check_database_connection(),
        'cache': check_cache_connection(),
        'external_api': check_external_api(),
        'disk_space': check_disk_space()
    }

    overall_status = 'healthy' if all(checks.values()) else 'unhealthy'

    return jsonify({
        'status': overall_status,
        'timestamp': time.time(),
        'checks': checks
    }), 200 if overall_status == 'healthy' else 503

def check_database_connection():
    try:
        # Test database connection
        db.execute("SELECT 1")
        return True
    except:
        return False
```

## Example: Basic Social Media System Design

### Requirements
- Users can post messages (140 characters)
- Users can follow other users
- Users see timeline of their followed users' posts
- 100M daily active users
- 1B posts per day

### Capacity Estimation
```
Daily Active Users: 100M
Posts per day: 1B
Read/Write ratio: 100:1

Write QPS: 1B / (24 * 3600) = ~11,600 posts/second
Read QPS: 11,600 * 100 = 1,160,000 reads/second

Storage:
- Post size: 140 chars + metadata = ~200 bytes
- Daily: 1B * 200 bytes = 200 GB/day
- 5 years: 200 GB * 365 * 5 = ~365 TB
```

### High-Level Design

```
[Mobile App] → [Load Balancer] → [API Gateway]
[Web App]                         ↓
                            [User Service]
                            [Post Service]
                            [Timeline Service]
                            [Notification Service]
                                  ↓
[CDN] ← [Media Storage] ← [Message Queue] → [Cache Layer]
                                ↓
                         [Database Cluster]
```

### Database Schema

```sql
-- Users table
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP,
    INDEX(username)
);

-- Posts table (sharded by user_id)
CREATE TABLE posts (
    post_id BIGINT PRIMARY KEY,
    user_id BIGINT,
    content VARCHAR(140),
    created_at TIMESTAMP,
    INDEX(user_id, created_at)
);

-- Followers table (sharded by follower_id)
CREATE TABLE followers (
    follower_id BIGINT,
    following_id BIGINT,
    created_at TIMESTAMP,
    PRIMARY KEY(follower_id, following_id),
    INDEX(following_id)
);
```

### Timeline Generation

#### Push Model (Write-Heavy)
```python
def post_message(user_id, content):
    # Save post
    post_id = posts_db.create_post(user_id, content)

    # Get followers
    followers = get_followers(user_id)

    # Push to followers' timelines (asynchronously)
    for follower_id in followers:
        timeline_cache.add_to_timeline(follower_id, post_id)
```

#### Pull Model (Read-Heavy)
```python
def get_timeline(user_id):
    # Get users that this user follows
    following = get_following(user_id)

    # Get recent posts from followed users
    timeline_posts = []
    for followed_user_id in following:
        posts = get_recent_posts(followed_user_id, limit=10)
        timeline_posts.extend(posts)

    # Sort by timestamp and return top N
    return sorted(timeline_posts, key=lambda x: x.created_at, reverse=True)[:50]
```

#### Hybrid Model
- Push for users with few followers (celebrities)
- Pull for users with many followers
- Cache frequently accessed timelines

## Summary

This basic HLSD guide covers:

1. **System Design Process**: Requirements to implementation
2. **Scalability**: Vertical vs horizontal scaling
3. **Load Balancing**: Distribution strategies and algorithms
4. **Caching**: Levels, patterns, and eviction policies
5. **Databases**: SQL vs NoSQL, scaling patterns
6. **CDN**: Content delivery and caching strategies
7. **Architecture Patterns**: Monolith to microservices
8. **API Design**: REST principles and best practices
9. **Security**: Authentication, authorization, common vulnerabilities
10. **Monitoring**: Metrics, logging, and alerting

These concepts form the foundation for designing large-scale distributed systems that can handle millions of users and massive amounts of data efficiently and reliably.