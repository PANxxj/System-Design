# Low Level System Design (LLSD) - Intermediate Concepts

## Table of Contents
1. [Advanced Design Patterns](#advanced-design-patterns)
2. [Caching Strategies](#caching-strategies)
3. [Database Design Patterns](#database-design-patterns)
4. [Concurrency and Multithreading](#concurrency-and-multithreading)
5. [Event-Driven Architecture](#event-driven-architecture)
6. [API Design Advanced](#api-design-advanced)
7. [Error Handling and Resilience](#error-handling-and-resilience)
8. [Performance Optimization](#performance-optimization)
9. [Security Patterns](#security-patterns)
10. [Testing Strategies](#testing-strategies)

## Advanced Design Patterns

### 1. Command Pattern
```python
from abc import ABC, abstractmethod
from typing import List

class Command(ABC):
    @abstractmethod
    def execute(self):
        pass

    @abstractmethod
    def undo(self):
        pass

class Light:
    def __init__(self):
        self.is_on = False

    def turn_on(self):
        self.is_on = True
        print("Light is ON")

    def turn_off(self):
        self.is_on = False
        print("Light is OFF")

class LightOnCommand(Command):
    def __init__(self, light: Light):
        self.light = light

    def execute(self):
        self.light.turn_on()

    def undo(self):
        self.light.turn_off()

class LightOffCommand(Command):
    def __init__(self, light: Light):
        self.light = light

    def execute(self):
        self.light.turn_off()

    def undo(self):
        self.light.turn_on()

class RemoteControl:
    def __init__(self):
        self.commands: List[Command] = []
        self.current_command = 0

    def submit(self, command: Command):
        self.commands.append(command)
        command.execute()
        self.current_command = len(self.commands) - 1

    def undo(self):
        if self.commands and self.current_command >= 0:
            self.commands[self.current_command].undo()
            self.current_command -= 1

# Usage
light = Light()
remote = RemoteControl()

on_command = LightOnCommand(light)
off_command = LightOffCommand(light)

remote.submit(on_command)   # Light is ON
remote.submit(off_command)  # Light is OFF
remote.undo()              # Light is ON
```

### 2. Chain of Responsibility Pattern
```python
class AuthenticationHandler(ABC):
    def __init__(self):
        self._next_handler = None

    def set_next(self, handler):
        self._next_handler = handler
        return handler

    @abstractmethod
    def handle(self, request):
        if self._next_handler:
            return self._next_handler.handle(request)
        return None

class APIKeyHandler(AuthenticationHandler):
    def handle(self, request):
        if 'api_key' in request and request['api_key'] == 'valid_key':
            print("Authenticated via API Key")
            return True
        print("API Key authentication failed")
        return super().handle(request)

class TokenHandler(AuthenticationHandler):
    def handle(self, request):
        if 'token' in request and self._validate_token(request['token']):
            print("Authenticated via Token")
            return True
        print("Token authentication failed")
        return super().handle(request)

    def _validate_token(self, token):
        return token == 'valid_token'

class BasicAuthHandler(AuthenticationHandler):
    def handle(self, request):
        if ('username' in request and 'password' in request and
            request['username'] == 'admin' and request['password'] == 'secret'):
            print("Authenticated via Basic Auth")
            return True
        print("Basic authentication failed")
        return super().handle(request)

# Usage
api_key_handler = APIKeyHandler()
token_handler = TokenHandler()
basic_auth_handler = BasicAuthHandler()

api_key_handler.set_next(token_handler).set_next(basic_auth_handler)

# Test different authentication methods
requests = [
    {'api_key': 'valid_key'},
    {'token': 'valid_token'},
    {'username': 'admin', 'password': 'secret'},
    {'invalid': 'data'}
]

for req in requests:
    result = api_key_handler.handle(req)
    print(f"Authentication result: {result}\n")
```

### 3. State Pattern
```python
class VendingMachineState(ABC):
    @abstractmethod
    def insert_coin(self, machine):
        pass

    @abstractmethod
    def select_product(self, machine):
        pass

    @abstractmethod
    def dispense(self, machine):
        pass

class IdleState(VendingMachineState):
    def insert_coin(self, machine):
        print("Coin inserted")
        machine.set_state(machine.coin_inserted_state)

    def select_product(self, machine):
        print("Please insert coin first")

    def dispense(self, machine):
        print("Please insert coin and select product")

class CoinInsertedState(VendingMachineState):
    def insert_coin(self, machine):
        print("Coin already inserted")

    def select_product(self, machine):
        print("Product selected")
        machine.set_state(machine.product_selected_state)

    def dispense(self, machine):
        print("Please select a product first")

class ProductSelectedState(VendingMachineState):
    def insert_coin(self, machine):
        print("Product already selected, processing...")

    def select_product(self, machine):
        print("Product already selected")

    def dispense(self, machine):
        print("Dispensing product")
        machine.set_state(machine.idle_state)

class VendingMachine:
    def __init__(self):
        self.idle_state = IdleState()
        self.coin_inserted_state = CoinInsertedState()
        self.product_selected_state = ProductSelectedState()
        self.current_state = self.idle_state

    def set_state(self, state):
        self.current_state = state

    def insert_coin(self):
        self.current_state.insert_coin(self)

    def select_product(self):
        self.current_state.select_product(self)

    def dispense(self):
        self.current_state.dispense(self)

# Usage
machine = VendingMachine()
machine.insert_coin()      # Coin inserted
machine.select_product()   # Product selected
machine.dispense()         # Dispensing product
```

## Caching Strategies

### 1. LRU Cache Implementation
```python
from collections import OrderedDict
import threading

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()
        self.lock = threading.RLock()

    def get(self, key):
        with self.lock:
            if key not in self.cache:
                return None
            # Move to end (most recently used)
            self.cache.move_to_end(key)
            return self.cache[key]

    def put(self, key, value):
        with self.lock:
            if key in self.cache:
                # Update existing key
                self.cache[key] = value
                self.cache.move_to_end(key)
            else:
                # Add new key
                if len(self.cache) >= self.capacity:
                    # Remove least recently used (first item)
                    self.cache.popitem(last=False)
                self.cache[key] = value

    def delete(self, key):
        with self.lock:
            if key in self.cache:
                del self.cache[key]
                return True
            return False

    def size(self):
        with self.lock:
            return len(self.cache)

    def clear(self):
        with self.lock:
            self.cache.clear()

# Usage
cache = LRUCache(3)
cache.put("a", 1)
cache.put("b", 2)
cache.put("c", 3)
print(cache.get("a"))  # 1
cache.put("d", 4)      # "b" is evicted
print(cache.get("b"))  # None
```

### 2. Cache-Aside Pattern
```python
import json
import time
from typing import Optional

class DatabaseService:
    def __init__(self):
        # Simulate database
        self.data = {
            "user:1": {"id": 1, "name": "John", "email": "john@example.com"},
            "user:2": {"id": 2, "name": "Jane", "email": "jane@example.com"}
        }

    def get_user(self, user_id: int) -> Optional[dict]:
        print(f"Database query for user {user_id}")
        time.sleep(0.1)  # Simulate DB latency
        return self.data.get(f"user:{user_id}")

    def update_user(self, user_id: int, user_data: dict):
        print(f"Updating user {user_id} in database")
        self.data[f"user:{user_id}"] = user_data

class CacheService:
    def __init__(self):
        self.cache = {}
        self.ttl = {}  # Time to live

    def get(self, key: str) -> Optional[str]:
        if key in self.cache:
            if key in self.ttl and time.time() > self.ttl[key]:
                # Expired
                del self.cache[key]
                del self.ttl[key]
                return None
            return self.cache[key]
        return None

    def set(self, key: str, value: str, ttl_seconds: int = 300):
        self.cache[key] = value
        self.ttl[key] = time.time() + ttl_seconds

    def delete(self, key: str):
        if key in self.cache:
            del self.cache[key]
        if key in self.ttl:
            del self.ttl[key]

class UserService:
    def __init__(self, db_service: DatabaseService, cache_service: CacheService):
        self.db = db_service
        self.cache = cache_service

    def get_user(self, user_id: int) -> Optional[dict]:
        cache_key = f"user:{user_id}"

        # Try cache first
        cached_data = self.cache.get(cache_key)
        if cached_data:
            print(f"Cache hit for user {user_id}")
            return json.loads(cached_data)

        # Cache miss - fetch from database
        print(f"Cache miss for user {user_id}")
        user_data = self.db.get_user(user_id)

        if user_data:
            # Store in cache
            self.cache.set(cache_key, json.dumps(user_data), ttl_seconds=300)

        return user_data

    def update_user(self, user_id: int, user_data: dict):
        # Update database
        self.db.update_user(user_id, user_data)

        # Invalidate cache
        cache_key = f"user:{user_id}"
        self.cache.delete(cache_key)
        print(f"Cache invalidated for user {user_id}")

# Usage
db_service = DatabaseService()
cache_service = CacheService()
user_service = UserService(db_service, cache_service)

# First call - cache miss
user = user_service.get_user(1)
print(f"User: {user}")

# Second call - cache hit
user = user_service.get_user(1)
print(f"User: {user}")

# Update user - cache invalidation
user_service.update_user(1, {"id": 1, "name": "John Updated", "email": "john.new@example.com"})

# Next call - cache miss again
user = user_service.get_user(1)
print(f"Updated User: {user}")
```

## Database Design Patterns

### 1. Repository Pattern with Unit of Work
```python
from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any
import threading

class Entity:
    def __init__(self, id=None):
        self.id = id
        self.is_deleted = False

class User(Entity):
    def __init__(self, id=None, name=None, email=None):
        super().__init__(id)
        self.name = name
        self.email = email

class Order(Entity):
    def __init__(self, id=None, user_id=None, total_amount=None):
        super().__init__(id)
        self.user_id = user_id
        self.total_amount = total_amount

class Repository(ABC):
    @abstractmethod
    def add(self, entity: Entity):
        pass

    @abstractmethod
    def get(self, id: Any) -> Optional[Entity]:
        pass

    @abstractmethod
    def update(self, entity: Entity):
        pass

    @abstractmethod
    def delete(self, entity: Entity):
        pass

    @abstractmethod
    def find_all(self) -> List[Entity]:
        pass

class InMemoryRepository(Repository):
    def __init__(self):
        self._entities: Dict[Any, Entity] = {}
        self._next_id = 1

    def add(self, entity: Entity):
        if entity.id is None:
            entity.id = self._next_id
            self._next_id += 1
        self._entities[entity.id] = entity

    def get(self, id: Any) -> Optional[Entity]:
        entity = self._entities.get(id)
        return entity if entity and not entity.is_deleted else None

    def update(self, entity: Entity):
        if entity.id in self._entities:
            self._entities[entity.id] = entity

    def delete(self, entity: Entity):
        if entity.id in self._entities:
            entity.is_deleted = True

    def find_all(self) -> List[Entity]:
        return [entity for entity in self._entities.values() if not entity.is_deleted]

class UserRepository(InMemoryRepository):
    def find_by_email(self, email: str) -> Optional[User]:
        for user in self.find_all():
            if user.email == email:
                return user
        return None

class OrderRepository(InMemoryRepository):
    def find_by_user_id(self, user_id: int) -> List[Order]:
        return [order for order in self.find_all() if order.user_id == user_id]

class UnitOfWork:
    def __init__(self):
        self._new_entities: List[Entity] = []
        self._dirty_entities: List[Entity] = []
        self._removed_entities: List[Entity] = []
        self._repositories: Dict[type, Repository] = {}
        self._lock = threading.Lock()

    def register_new(self, entity: Entity):
        with self._lock:
            if entity not in self._dirty_entities and entity not in self._removed_entities:
                self._new_entities.append(entity)

    def register_dirty(self, entity: Entity):
        with self._lock:
            if entity not in self._new_entities and entity not in self._removed_entities:
                if entity not in self._dirty_entities:
                    self._dirty_entities.append(entity)

    def register_removed(self, entity: Entity):
        with self._lock:
            if entity in self._new_entities:
                self._new_entities.remove(entity)
            elif entity not in self._removed_entities:
                self._dirty_entities = [e for e in self._dirty_entities if e != entity]
                self._removed_entities.append(entity)

    def register_repository(self, entity_type: type, repository: Repository):
        self._repositories[entity_type] = repository

    def commit(self):
        with self._lock:
            try:
                # Add new entities
                for entity in self._new_entities:
                    repo = self._repositories.get(type(entity))
                    if repo:
                        repo.add(entity)

                # Update dirty entities
                for entity in self._dirty_entities:
                    repo = self._repositories.get(type(entity))
                    if repo:
                        repo.update(entity)

                # Remove entities
                for entity in self._removed_entities:
                    repo = self._repositories.get(type(entity))
                    if repo:
                        repo.delete(entity)

                # Clear tracking lists
                self._new_entities.clear()
                self._dirty_entities.clear()
                self._removed_entities.clear()

                print("Transaction committed successfully")

            except Exception as e:
                self.rollback()
                raise e

    def rollback(self):
        with self._lock:
            self._new_entities.clear()
            self._dirty_entities.clear()
            self._removed_entities.clear()
            print("Transaction rolled back")

# Service layer
class UserService:
    def __init__(self, unit_of_work: UnitOfWork, user_repository: UserRepository):
        self.uow = unit_of_work
        self.user_repo = user_repository

    def create_user(self, name: str, email: str) -> User:
        # Check if user already exists
        existing_user = self.user_repo.find_by_email(email)
        if existing_user:
            raise ValueError("User with this email already exists")

        user = User(name=name, email=email)
        self.uow.register_new(user)
        return user

    def update_user(self, user_id: int, name: str = None, email: str = None):
        user = self.user_repo.get(user_id)
        if not user:
            raise ValueError("User not found")

        if name:
            user.name = name
        if email:
            user.email = email

        self.uow.register_dirty(user)

    def delete_user(self, user_id: int):
        user = self.user_repo.get(user_id)
        if not user:
            raise ValueError("User not found")

        self.uow.register_removed(user)

# Usage
uow = UnitOfWork()
user_repo = UserRepository()
order_repo = OrderRepository()

uow.register_repository(User, user_repo)
uow.register_repository(Order, order_repo)

user_service = UserService(uow, user_repo)

# Create and modify users within a transaction
try:
    user1 = user_service.create_user("John Doe", "john@example.com")
    user2 = user_service.create_user("Jane Smith", "jane@example.com")

    user_service.update_user(user1.id, name="John Updated")

    # Commit all changes
    uow.commit()

    print(f"Users created: {len(user_repo.find_all())}")

except Exception as e:
    print(f"Error: {e}")
```

### 2. Data Access Object (DAO) Pattern
```python
from abc import ABC, abstractmethod
from typing import List, Optional
import sqlite3
from contextlib import contextmanager

class UserDAO(ABC):
    @abstractmethod
    def create(self, user: User) -> User:
        pass

    @abstractmethod
    def get_by_id(self, user_id: int) -> Optional[User]:
        pass

    @abstractmethod
    def get_by_email(self, email: str) -> Optional[User]:
        pass

    @abstractmethod
    def update(self, user: User) -> bool:
        pass

    @abstractmethod
    def delete(self, user_id: int) -> bool:
        pass

    @abstractmethod
    def get_all(self) -> List[User]:
        pass

class SQLiteUserDAO(UserDAO):
    def __init__(self, db_path: str):
        self.db_path = db_path
        self._init_database()

    def _init_database(self):
        with self._get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT UNIQUE NOT NULL
                )
            ''')
            conn.commit()

    @contextmanager
    def _get_connection(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    def create(self, user: User) -> User:
        with self._get_connection() as conn:
            cursor = conn.execute(
                'INSERT INTO users (name, email) VALUES (?, ?)',
                (user.name, user.email)
            )
            user.id = cursor.lastrowid
            conn.commit()
            return user

    def get_by_id(self, user_id: int) -> Optional[User]:
        with self._get_connection() as conn:
            cursor = conn.execute(
                'SELECT * FROM users WHERE id = ?',
                (user_id,)
            )
            row = cursor.fetchone()
            if row:
                return User(id=row['id'], name=row['name'], email=row['email'])
            return None

    def get_by_email(self, email: str) -> Optional[User]:
        with self._get_connection() as conn:
            cursor = conn.execute(
                'SELECT * FROM users WHERE email = ?',
                (email,)
            )
            row = cursor.fetchone()
            if row:
                return User(id=row['id'], name=row['name'], email=row['email'])
            return None

    def update(self, user: User) -> bool:
        with self._get_connection() as conn:
            cursor = conn.execute(
                'UPDATE users SET name = ?, email = ? WHERE id = ?',
                (user.name, user.email, user.id)
            )
            conn.commit()
            return cursor.rowcount > 0

    def delete(self, user_id: int) -> bool:
        with self._get_connection() as conn:
            cursor = conn.execute(
                'DELETE FROM users WHERE id = ?',
                (user_id,)
            )
            conn.commit()
            return cursor.rowcount > 0

    def get_all(self) -> List[User]:
        with self._get_connection() as conn:
            cursor = conn.execute('SELECT * FROM users')
            rows = cursor.fetchall()
            return [User(id=row['id'], name=row['name'], email=row['email']) for row in rows]

# Usage
user_dao = SQLiteUserDAO(':memory:')

# Create users
user1 = User(name="John Doe", email="john@example.com")
user2 = User(name="Jane Smith", email="jane@example.com")

created_user1 = user_dao.create(user1)
created_user2 = user_dao.create(user2)

print(f"Created user: {created_user1.id}")

# Retrieve user
retrieved_user = user_dao.get_by_email("john@example.com")
print(f"Retrieved user: {retrieved_user.name}")

# Update user
retrieved_user.name = "John Updated"
user_dao.update(retrieved_user)

# Get all users
all_users = user_dao.get_all()
print(f"Total users: {len(all_users)}")
```

## Concurrency and Multithreading

### 1. Thread Pool Pattern
```python
import threading
import time
from queue import Queue, Empty
from typing import Callable, Any, List
from concurrent.futures import ThreadPoolExecutor, Future

class Task:
    def __init__(self, func: Callable, *args, **kwargs):
        self.func = func
        self.args = args
        self.kwargs = kwargs
        self.result = None
        self.exception = None
        self.completed = threading.Event()

    def execute(self):
        try:
            self.result = self.func(*self.args, **self.kwargs)
        except Exception as e:
            self.exception = e
        finally:
            self.completed.set()

    def get_result(self, timeout=None):
        if self.completed.wait(timeout):
            if self.exception:
                raise self.exception
            return self.result
        raise TimeoutError("Task did not complete within timeout")

class ThreadPool:
    def __init__(self, num_threads: int):
        self.num_threads = num_threads
        self.task_queue = Queue()
        self.workers: List[threading.Thread] = []
        self.shutdown_flag = threading.Event()
        self._start_workers()

    def _start_workers(self):
        for i in range(self.num_threads):
            worker = threading.Thread(target=self._worker, name=f"Worker-{i}")
            worker.start()
            self.workers.append(worker)

    def _worker(self):
        while not self.shutdown_flag.is_set():
            try:
                task = self.task_queue.get(timeout=1)
                if task is None:  # Poison pill
                    break
                task.execute()
                self.task_queue.task_done()
            except Empty:
                continue

    def submit(self, func: Callable, *args, **kwargs) -> Task:
        if self.shutdown_flag.is_set():
            raise RuntimeError("Thread pool is shutdown")

        task = Task(func, *args, **kwargs)
        self.task_queue.put(task)
        return task

    def shutdown(self, wait=True):
        self.shutdown_flag.set()

        # Send poison pills
        for _ in self.workers:
            self.task_queue.put(None)

        if wait:
            for worker in self.workers:
                worker.join()

# Example usage
def heavy_computation(n: int) -> int:
    time.sleep(1)  # Simulate heavy work
    return n * n

# Using custom thread pool
thread_pool = ThreadPool(num_threads=3)

tasks = []
for i in range(5):
    task = thread_pool.submit(heavy_computation, i)
    tasks.append(task)

# Wait for all tasks to complete
for i, task in enumerate(tasks):
    result = task.get_result()
    print(f"Task {i} result: {result}")

thread_pool.shutdown()

# Using built-in ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=3) as executor:
    futures = [executor.submit(heavy_computation, i) for i in range(5)]

    for i, future in enumerate(futures):
        result = future.result()
        print(f"Future {i} result: {result}")
```

### 2. Read-Write Lock
```python
import threading
import time
from typing import Dict, Any

class ReadWriteLock:
    def __init__(self):
        self._read_ready = threading.Condition(threading.RLock())
        self._readers = 0

    def acquire_read(self):
        self._read_ready.acquire()
        try:
            self._readers += 1
        finally:
            self._read_ready.release()

    def release_read(self):
        self._read_ready.acquire()
        try:
            self._readers -= 1
            if self._readers == 0:
                self._read_ready.notifyAll()
        finally:
            self._read_ready.release()

    def acquire_write(self):
        self._read_ready.acquire()
        while self._readers > 0:
            self._read_ready.wait()

    def release_write(self):
        self._read_ready.release()

class ReadWriteContextManager:
    def __init__(self, lock: ReadWriteLock, is_read: bool):
        self.lock = lock
        self.is_read = is_read

    def __enter__(self):
        if self.is_read:
            self.lock.acquire_read()
        else:
            self.lock.acquire_write()

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.is_read:
            self.lock.release_read()
        else:
            self.lock.release_write()

class ThreadSafeCache:
    def __init__(self):
        self._cache: Dict[str, Any] = {}
        self._lock = ReadWriteLock()

    def get(self, key: str) -> Any:
        with ReadWriteContextManager(self._lock, is_read=True):
            print(f"Reading key: {key} by {threading.current_thread().name}")
            time.sleep(0.1)  # Simulate read operation
            return self._cache.get(key)

    def put(self, key: str, value: Any):
        with ReadWriteContextManager(self._lock, is_read=False):
            print(f"Writing key: {key} by {threading.current_thread().name}")
            time.sleep(0.2)  # Simulate write operation
            self._cache[key] = value

    def size(self) -> int:
        with ReadWriteContextManager(self._lock, is_read=True):
            return len(self._cache)

# Usage example
cache = ThreadSafeCache()

def reader_task(cache: ThreadSafeCache, key: str):
    for i in range(3):
        value = cache.get(key)
        print(f"Reader {threading.current_thread().name} read: {value}")
        time.sleep(0.1)

def writer_task(cache: ThreadSafeCache, key: str, value: Any):
    cache.put(key, value)
    print(f"Writer {threading.current_thread().name} wrote: {value}")

# Start multiple readers and writers
threads = []

# Start writers
for i in range(2):
    t = threading.Thread(target=writer_task, args=(cache, f"key{i}", f"value{i}"), name=f"Writer-{i}")
    threads.append(t)
    t.start()

# Start readers
for i in range(3):
    t = threading.Thread(target=reader_task, args=(cache, "key0"), name=f"Reader-{i}")
    threads.append(t)
    t.start()

# Wait for all threads
for t in threads:
    t.join()
```

## Event-Driven Architecture

### 1. Event System Implementation
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Callable, Any
import threading
import time
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Event:
    event_type: str
    data: Dict[str, Any]
    timestamp: datetime
    event_id: str = None

    def __post_init__(self):
        if self.event_id is None:
            import uuid
            self.event_id = str(uuid.uuid4())

class EventHandler(ABC):
    @abstractmethod
    def handle(self, event: Event):
        pass

class EventBus:
    def __init__(self):
        self._handlers: Dict[str, List[EventHandler]] = {}
        self._lock = threading.RLock()

    def subscribe(self, event_type: str, handler: EventHandler):
        with self._lock:
            if event_type not in self._handlers:
                self._handlers[event_type] = []
            self._handlers[event_type].append(handler)

    def unsubscribe(self, event_type: str, handler: EventHandler):
        with self._lock:
            if event_type in self._handlers:
                self._handlers[event_type] = [h for h in self._handlers[event_type] if h != handler]

    def publish(self, event: Event):
        with self._lock:
            handlers = self._handlers.get(event.event_type, []).copy()

        # Execute handlers outside of lock to avoid deadlock
        for handler in handlers:
            try:
                handler.handle(event)
            except Exception as e:
                print(f"Error handling event {event.event_id}: {e}")

class AsyncEventBus(EventBus):
    def __init__(self, max_workers: int = 5):
        super().__init__()
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    def publish(self, event: Event):
        with self._lock:
            handlers = self._handlers.get(event.event_type, []).copy()

        # Execute handlers asynchronously
        for handler in handlers:
            self.executor.submit(self._safe_handle, handler, event)

    def _safe_handle(self, handler: EventHandler, event: Event):
        try:
            handler.handle(event)
        except Exception as e:
            print(f"Error handling event {event.event_id}: {e}")

    def shutdown(self):
        self.executor.shutdown(wait=True)

# Example event handlers
class EmailNotificationHandler(EventHandler):
    def handle(self, event: Event):
        print(f"Sending email notification for event: {event.event_type}")
        time.sleep(0.1)  # Simulate email sending
        print(f"Email sent for event {event.event_id}")

class LoggingHandler(EventHandler):
    def handle(self, event: Event):
        print(f"[LOG] {event.timestamp}: {event.event_type} - {event.data}")

class MetricsHandler(EventHandler):
    def __init__(self):
        self.event_count = 0
        self.lock = threading.Lock()

    def handle(self, event: Event):
        with self.lock:
            self.event_count += 1
            print(f"[METRICS] Total events processed: {self.event_count}")

# Usage example
event_bus = AsyncEventBus()

# Subscribe handlers
email_handler = EmailNotificationHandler()
logging_handler = LoggingHandler()
metrics_handler = MetricsHandler()

event_bus.subscribe("user.created", email_handler)
event_bus.subscribe("user.created", logging_handler)
event_bus.subscribe("user.created", metrics_handler)

event_bus.subscribe("order.placed", logging_handler)
event_bus.subscribe("order.placed", metrics_handler)

# Publish events
user_created_event = Event(
    event_type="user.created",
    data={"user_id": 123, "email": "user@example.com"},
    timestamp=datetime.now()
)

order_placed_event = Event(
    event_type="order.placed",
    data={"order_id": 456, "user_id": 123, "amount": 99.99},
    timestamp=datetime.now()
)

event_bus.publish(user_created_event)
event_bus.publish(order_placed_event)

# Wait for async processing
time.sleep(1)
event_bus.shutdown()
```

### 2. CQRS (Command Query Responsibility Segregation)
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
import uuid
from datetime import datetime

# Commands (Write side)
@dataclass
class Command:
    command_id: str = None

    def __post_init__(self):
        if self.command_id is None:
            self.command_id = str(uuid.uuid4())

@dataclass
class CreateUserCommand(Command):
    name: str
    email: str

@dataclass
class UpdateUserCommand(Command):
    user_id: str
    name: Optional[str] = None
    email: Optional[str] = None

# Queries (Read side)
@dataclass
class Query:
    pass

@dataclass
class GetUserQuery(Query):
    user_id: str

@dataclass
class GetUsersByEmailQuery(Query):
    email: str

# Events
@dataclass
class DomainEvent:
    event_id: str
    aggregate_id: str
    timestamp: datetime
    version: int

@dataclass
class UserCreatedEvent(DomainEvent):
    name: str
    email: str

@dataclass
class UserUpdatedEvent(DomainEvent):
    name: Optional[str] = None
    email: Optional[str] = None

# Aggregate (Write model)
class User:
    def __init__(self, user_id: str, name: str, email: str):
        self.user_id = user_id
        self.name = name
        self.email = email
        self.version = 0
        self._uncommitted_events: List[DomainEvent] = []

    def update(self, name: str = None, email: str = None):
        if name:
            self.name = name
        if email:
            self.email = email

        self.version += 1
        event = UserUpdatedEvent(
            event_id=str(uuid.uuid4()),
            aggregate_id=self.user_id,
            timestamp=datetime.now(),
            version=self.version,
            name=name,
            email=email
        )
        self._uncommitted_events.append(event)

    def get_uncommitted_events(self) -> List[DomainEvent]:
        return self._uncommitted_events.copy()

    def mark_events_committed(self):
        self._uncommitted_events.clear()

    @classmethod
    def create(cls, name: str, email: str) -> 'User':
        user_id = str(uuid.uuid4())
        user = cls(user_id, name, email)
        user.version = 1

        event = UserCreatedEvent(
            event_id=str(uuid.uuid4()),
            aggregate_id=user_id,
            timestamp=datetime.now(),
            version=user.version,
            name=name,
            email=email
        )
        user._uncommitted_events.append(event)
        return user

# Read model
@dataclass
class UserReadModel:
    user_id: str
    name: str
    email: str
    created_at: datetime
    updated_at: datetime

# Command handlers
class CommandHandler(ABC):
    @abstractmethod
    def handle(self, command: Command):
        pass

class CreateUserCommandHandler(CommandHandler):
    def __init__(self, user_repository, event_bus):
        self.user_repository = user_repository
        self.event_bus = event_bus

    def handle(self, command: CreateUserCommand):
        # Check if user already exists
        existing_user = self.user_repository.find_by_email(command.email)
        if existing_user:
            raise ValueError("User with this email already exists")

        # Create new user
        user = User.create(command.name, command.email)

        # Save to repository
        self.user_repository.save(user)

        # Publish events
        for event in user.get_uncommitted_events():
            self.event_bus.publish(event)

        user.mark_events_committed()
        return user.user_id

# Query handlers
class QueryHandler(ABC):
    @abstractmethod
    def handle(self, query: Query):
        pass

class GetUserQueryHandler(QueryHandler):
    def __init__(self, read_model_repository):
        self.read_model_repository = read_model_repository

    def handle(self, query: GetUserQuery) -> Optional[UserReadModel]:
        return self.read_model_repository.find_by_id(query.user_id)

# Repositories
class UserRepository:
    def __init__(self):
        self._users: Dict[str, User] = {}

    def save(self, user: User):
        self._users[user.user_id] = user

    def find_by_id(self, user_id: str) -> Optional[User]:
        return self._users.get(user_id)

    def find_by_email(self, email: str) -> Optional[User]:
        for user in self._users.values():
            if user.email == email:
                return user
        return None

class UserReadModelRepository:
    def __init__(self):
        self._read_models: Dict[str, UserReadModel] = {}

    def save(self, read_model: UserReadModel):
        self._read_models[read_model.user_id] = read_model

    def find_by_id(self, user_id: str) -> Optional[UserReadModel]:
        return self._read_models.get(user_id)

# Event handlers for updating read models
class UserCreatedEventHandler(EventHandler):
    def __init__(self, read_model_repository):
        self.read_model_repository = read_model_repository

    def handle(self, event: Event):
        if isinstance(event, UserCreatedEvent):
            read_model = UserReadModel(
                user_id=event.aggregate_id,
                name=event.name,
                email=event.email,
                created_at=event.timestamp,
                updated_at=event.timestamp
            )
            self.read_model_repository.save(read_model)

# CQRS Bus
class CQRSBus:
    def __init__(self):
        self._command_handlers: Dict[type, CommandHandler] = {}
        self._query_handlers: Dict[type, QueryHandler] = {}

    def register_command_handler(self, command_type: type, handler: CommandHandler):
        self._command_handlers[command_type] = handler

    def register_query_handler(self, query_type: type, handler: QueryHandler):
        self._query_handlers[query_type] = handler

    def send_command(self, command: Command):
        handler = self._command_handlers.get(type(command))
        if not handler:
            raise ValueError(f"No handler registered for command {type(command)}")
        return handler.handle(command)

    def send_query(self, query: Query):
        handler = self._query_handlers.get(type(query))
        if not handler:
            raise ValueError(f"No handler registered for query {type(query)}")
        return handler.handle(query)

# Usage
event_bus = EventBus()
user_repository = UserRepository()
read_model_repository = UserReadModelRepository()

# Set up handlers
create_user_handler = CreateUserCommandHandler(user_repository, event_bus)
get_user_handler = GetUserQueryHandler(read_model_repository)
user_created_event_handler = UserCreatedEventHandler(read_model_repository)

# Register handlers
cqrs_bus = CQRSBus()
cqrs_bus.register_command_handler(CreateUserCommand, create_user_handler)
cqrs_bus.register_query_handler(GetUserQuery, get_user_handler)

event_bus.subscribe("UserCreatedEvent", user_created_event_handler)

# Execute commands and queries
create_command = CreateUserCommand(name="John Doe", email="john@example.com")
user_id = cqrs_bus.send_command(create_command)

get_query = GetUserQuery(user_id=user_id)
user_read_model = cqrs_bus.send_query(get_query)

print(f"User read model: {user_read_model}")
```

## Summary

This intermediate LLSD guide covers:

1. **Advanced Design Patterns**: Command, Chain of Responsibility, State patterns
2. **Caching Strategies**: LRU Cache, Cache-Aside pattern
3. **Database Patterns**: Repository with Unit of Work, DAO pattern
4. **Concurrency**: Thread pools, Read-Write locks
5. **Event-Driven Architecture**: Event bus, CQRS pattern

These patterns help build more sophisticated, scalable, and maintainable systems while handling complex requirements like caching, transactions, and asynchronous processing.