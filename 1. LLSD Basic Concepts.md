# Low Level System Design (LLSD) - Basic Concepts

## Table of Contents
1. [Introduction to LLSD](#introduction-to-llsd)
2. [Object-Oriented Programming Principles](#object-oriented-programming-principles)
3. [SOLID Principles](#solid-principles)
4. [Design Patterns - Creational](#design-patterns---creational)
5. [Design Patterns - Structural](#design-patterns---structural)
6. [Design Patterns - Behavioral](#design-patterns---behavioral)
7. [Basic System Components](#basic-system-components)
8. [Data Modeling](#data-modeling)
9. [API Design Basics](#api-design-basics)
10. [Basic Concurrency](#basic-concurrency)

## Introduction to LLSD

**Low Level System Design** focuses on the detailed design of individual components and their interactions within a system. It deals with:

- **Class diagrams and relationships**
- **Database schema design**
- **API contracts**
- **Design patterns implementation**
- **Code organization and architecture**

### Key Differences: LLSD vs HLSD
| Aspect | LLSD | HLSD |
|--------|------|------|
| Scope | Component-level | System-level |
| Focus | Classes, methods, DB schema | Services, infrastructure |
| Detail | High detail | High-level overview |
| Tools | UML, ERD | Architecture diagrams |

## Object-Oriented Programming Principles

### 1. Encapsulation
```python
class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number  # Private
        self.__balance = initial_balance        # Private

    def get_balance(self):
        return self.__balance

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False
```

### 2. Inheritance
```python
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def start_engine(self):
        print("Engine started")

class Car(Vehicle):
    def __init__(self, brand, model, doors):
        super().__init__(brand, model)
        self.doors = doors

    def honk(self):
        print("Car honking")
```

### 3. Polymorphism
```python
class Shape:
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14159 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height
```

### 4. Abstraction
```python
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount):
        pass

    @abstractmethod
    def validate_payment(self, payment_details):
        pass

class CreditCardProcessor(PaymentProcessor):
    def process_payment(self, amount):
        # Credit card specific logic
        print(f"Processing ${amount} via Credit Card")

    def validate_payment(self, payment_details):
        # Validation logic
        return True
```

## SOLID Principles

### 1. Single Responsibility Principle (SRP)
```python
# Bad - Multiple responsibilities
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def save_to_database(self):
        # Database logic
        pass

    def send_email(self):
        # Email logic
        pass

# Good - Single responsibility
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user):
        # Database logic
        pass

class EmailService:
    def send_email(self, user, message):
        # Email logic
        pass
```

### 2. Open/Closed Principle (OCP)
```python
class DiscountCalculator:
    def calculate_discount(self, customer_type, amount):
        if customer_type == "regular":
            return amount * 0.05
        elif customer_type == "premium":
            return amount * 0.10
        elif customer_type == "vip":
            return amount * 0.15

# Better approach - Open for extension, closed for modification
class DiscountStrategy(ABC):
    @abstractmethod
    def calculate_discount(self, amount):
        pass

class RegularDiscount(DiscountStrategy):
    def calculate_discount(self, amount):
        return amount * 0.05

class PremiumDiscount(DiscountStrategy):
    def calculate_discount(self, amount):
        return amount * 0.10

class DiscountCalculator:
    def __init__(self, strategy: DiscountStrategy):
        self.strategy = strategy

    def calculate(self, amount):
        return self.strategy.calculate_discount(amount)
```

### 3. Liskov Substitution Principle (LSP)
```python
class Bird:
    def fly(self):
        pass

class Sparrow(Bird):
    def fly(self):
        print("Sparrow flying")

class Penguin(Bird):
    def fly(self):
        raise Exception("Penguins can't fly")  # Violates LSP

# Better design
class Bird:
    def move(self):
        pass

class FlyingBird(Bird):
    def fly(self):
        pass

class Sparrow(FlyingBird):
    def fly(self):
        print("Sparrow flying")

    def move(self):
        self.fly()

class Penguin(Bird):
    def swim(self):
        print("Penguin swimming")

    def move(self):
        self.swim()
```

### 4. Interface Segregation Principle (ISP)
```python
# Bad - Fat interface
class Machine(ABC):
    @abstractmethod
    def print(self):
        pass

    @abstractmethod
    def scan(self):
        pass

    @abstractmethod
    def fax(self):
        pass

# Good - Segregated interfaces
class Printer(ABC):
    @abstractmethod
    def print(self):
        pass

class Scanner(ABC):
    @abstractmethod
    def scan(self):
        pass

class FaxMachine(ABC):
    @abstractmethod
    def fax(self):
        pass

class MultiFunctionPrinter(Printer, Scanner, FaxMachine):
    def print(self):
        print("Printing...")

    def scan(self):
        print("Scanning...")

    def fax(self):
        print("Faxing...")
```

### 5. Dependency Inversion Principle (DIP)
```python
# Bad - High-level module depends on low-level module
class MySQLDatabase:
    def save(self, data):
        print("Saving to MySQL")

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # Direct dependency

    def create_user(self, user_data):
        self.db.save(user_data)

# Good - Both depend on abstraction
class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        print("Saving to MySQL")

class UserService:
    def __init__(self, database: Database):
        self.db = database  # Depends on abstraction

    def create_user(self, user_data):
        self.db.save(user_data)
```

## Design Patterns - Creational

### 1. Singleton Pattern
```python
class DatabaseConnection:
    _instance = None
    _connection = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def connect(self):
        if self._connection is None:
            self._connection = "Database Connection Established"
        return self._connection

# Usage
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(db1 is db2)  # True
```

### 2. Factory Pattern
```python
class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError("Unknown animal type")

# Usage
animal = AnimalFactory.create_animal("dog")
print(animal.make_sound())  # Woof!
```

### 3. Builder Pattern
```python
class Computer:
    def __init__(self):
        self.cpu = None
        self.memory = None
        self.storage = None
        self.gpu = None

    def __str__(self):
        return f"CPU: {self.cpu}, Memory: {self.memory}, Storage: {self.storage}, GPU: {self.gpu}"

class ComputerBuilder:
    def __init__(self):
        self.computer = Computer()

    def set_cpu(self, cpu):
        self.computer.cpu = cpu
        return self

    def set_memory(self, memory):
        self.computer.memory = memory
        return self

    def set_storage(self, storage):
        self.computer.storage = storage
        return self

    def set_gpu(self, gpu):
        self.computer.gpu = gpu
        return self

    def build(self):
        return self.computer

# Usage
computer = (ComputerBuilder()
           .set_cpu("Intel i7")
           .set_memory("16GB")
           .set_storage("512GB SSD")
           .set_gpu("RTX 3080")
           .build())
```

## Design Patterns - Structural

### 1. Adapter Pattern
```python
class OldPrinter:
    def old_print(self, text):
        print(f"Old printer: {text}")

class NewPrinter:
    def print(self, text):
        print(f"New printer: {text}")

class PrinterAdapter:
    def __init__(self, old_printer):
        self.old_printer = old_printer

    def print(self, text):
        self.old_printer.old_print(text)

# Usage
old_printer = OldPrinter()
adapter = PrinterAdapter(old_printer)
adapter.print("Hello World")  # Old printer: Hello World
```

### 2. Decorator Pattern
```python
class Coffee:
    def cost(self):
        return 5

    def description(self):
        return "Simple coffee"

class CoffeeDecorator:
    def __init__(self, coffee):
        self.coffee = coffee

    def cost(self):
        return self.coffee.cost()

    def description(self):
        return self.coffee.description()

class MilkDecorator(CoffeeDecorator):
    def cost(self):
        return self.coffee.cost() + 2

    def description(self):
        return self.coffee.description() + ", milk"

class SugarDecorator(CoffeeDecorator):
    def cost(self):
        return self.coffee.cost() + 1

    def description(self):
        return self.coffee.description() + ", sugar"

# Usage
coffee = Coffee()
coffee_with_milk = MilkDecorator(coffee)
coffee_with_milk_and_sugar = SugarDecorator(coffee_with_milk)
print(f"{coffee_with_milk_and_sugar.description()}: ${coffee_with_milk_and_sugar.cost()}")
```

## Design Patterns - Behavioral

### 1. Observer Pattern
```python
class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update(self._state)

    def set_state(self, state):
        self._state = state
        self.notify()

class Observer(ABC):
    @abstractmethod
    def update(self, state):
        pass

class EmailNotifier(Observer):
    def update(self, state):
        print(f"Email notification: State changed to {state}")

class SMSNotifier(Observer):
    def update(self, state):
        print(f"SMS notification: State changed to {state}")

# Usage
subject = Subject()
email_notifier = EmailNotifier()
sms_notifier = SMSNotifier()

subject.attach(email_notifier)
subject.attach(sms_notifier)
subject.set_state("Active")
```

### 2. Strategy Pattern
```python
class SortStrategy(ABC):
    @abstractmethod
    def sort(self, data):
        pass

class BubbleSort(SortStrategy):
    def sort(self, data):
        print("Sorting using bubble sort")
        return sorted(data)

class QuickSort(SortStrategy):
    def sort(self, data):
        print("Sorting using quick sort")
        return sorted(data)

class Sorter:
    def __init__(self, strategy: SortStrategy):
        self.strategy = strategy

    def set_strategy(self, strategy: SortStrategy):
        self.strategy = strategy

    def sort_data(self, data):
        return self.strategy.sort(data)

# Usage
data = [64, 34, 25, 12, 22, 11, 90]
sorter = Sorter(BubbleSort())
sorted_data = sorter.sort_data(data.copy())
```

## Basic System Components

### 1. Model-View-Controller (MVC)
```python
# Model
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserModel:
    def __init__(self):
        self.users = []

    def add_user(self, user):
        self.users.append(user)

    def get_users(self):
        return self.users

# View
class UserView:
    def display_users(self, users):
        for user in users:
            print(f"Name: {user.name}, Email: {user.email}")

    def display_message(self, message):
        print(message)

# Controller
class UserController:
    def __init__(self, model, view):
        self.model = model
        self.view = view

    def add_user(self, name, email):
        user = User(name, email)
        self.model.add_user(user)
        self.view.display_message(f"User {name} added successfully")

    def show_users(self):
        users = self.model.get_users()
        self.view.display_users(users)
```

### 2. Repository Pattern
```python
class User:
    def __init__(self, id, name, email):
        self.id = id
        self.name = name
        self.email = email

class UserRepository(ABC):
    @abstractmethod
    def save(self, user):
        pass

    @abstractmethod
    def find_by_id(self, user_id):
        pass

    @abstractmethod
    def find_all(self):
        pass

class InMemoryUserRepository(UserRepository):
    def __init__(self):
        self.users = {}
        self.next_id = 1

    def save(self, user):
        if user.id is None:
            user.id = self.next_id
            self.next_id += 1
        self.users[user.id] = user
        return user

    def find_by_id(self, user_id):
        return self.users.get(user_id)

    def find_all(self):
        return list(self.users.values())

class UserService:
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository

    def create_user(self, name, email):
        user = User(None, name, email)
        return self.user_repository.save(user)

    def get_user(self, user_id):
        return self.user_repository.find_by_id(user_id)
```

## Data Modeling

### 1. Entity Relationship Design
```python
from datetime import datetime
from enum import Enum

class OrderStatus(Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

class Customer:
    def __init__(self, customer_id, name, email, phone):
        self.customer_id = customer_id
        self.name = name
        self.email = email
        self.phone = phone
        self.orders = []

class Product:
    def __init__(self, product_id, name, price, stock_quantity):
        self.product_id = product_id
        self.name = name
        self.price = price
        self.stock_quantity = stock_quantity

class OrderItem:
    def __init__(self, product, quantity, unit_price):
        self.product = product
        self.quantity = quantity
        self.unit_price = unit_price

    def get_total_price(self):
        return self.quantity * self.unit_price

class Order:
    def __init__(self, order_id, customer):
        self.order_id = order_id
        self.customer = customer
        self.order_date = datetime.now()
        self.status = OrderStatus.PENDING
        self.items = []

    def add_item(self, product, quantity):
        if product.stock_quantity >= quantity:
            item = OrderItem(product, quantity, product.price)
            self.items.append(item)
            product.stock_quantity -= quantity
            return True
        return False

    def get_total_amount(self):
        return sum(item.get_total_price() for item in self.items)

    def update_status(self, status: OrderStatus):
        self.status = status
```

### 2. Database Schema Design
```sql
-- Customer table
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(15),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Product table
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    stock_quantity INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Order table
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(customer_id),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending',
    total_amount DECIMAL(10, 2)
);

-- Order items table
CREATE TABLE order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(order_id),
    product_id INTEGER REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10, 2) NOT NULL
);
```

## API Design Basics

### 1. RESTful API Design
```python
from flask import Flask, request, jsonify

app = Flask(__name__)

# GET /api/users - Get all users
@app.route('/api/users', methods=['GET'])
def get_users():
    page = request.args.get('page', 1, type=int)
    limit = request.args.get('limit', 10, type=int)

    # Pagination logic
    users = user_service.get_users(page, limit)
    return jsonify({
        'users': users,
        'page': page,
        'limit': limit,
        'total': user_service.get_total_count()
    })

# GET /api/users/{id} - Get user by ID
@app.route('/api/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    user = user_service.get_user(user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(user)

# POST /api/users - Create new user
@app.route('/api/users', methods=['POST'])
def create_user():
    data = request.get_json()

    # Validation
    if not data.get('name') or not data.get('email'):
        return jsonify({'error': 'Name and email are required'}), 400

    try:
        user = user_service.create_user(data['name'], data['email'])
        return jsonify(user), 201
    except ValidationError as e:
        return jsonify({'error': str(e)}), 400

# PUT /api/users/{id} - Update user
@app.route('/api/users/<int:user_id>', methods=['PUT'])
def update_user(user_id):
    data = request.get_json()

    try:
        user = user_service.update_user(user_id, data)
        if not user:
            return jsonify({'error': 'User not found'}), 404
        return jsonify(user)
    except ValidationError as e:
        return jsonify({'error': str(e)}), 400

# DELETE /api/users/{id} - Delete user
@app.route('/api/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    success = user_service.delete_user(user_id)
    if not success:
        return jsonify({'error': 'User not found'}), 404
    return '', 204
```

### 2. API Response Standards
```python
class APIResponse:
    @staticmethod
    def success(data=None, message="Success", status_code=200):
        response = {
            'success': True,
            'message': message,
            'data': data
        }
        return jsonify(response), status_code

    @staticmethod
    def error(message="Error occurred", status_code=400, error_code=None):
        response = {
            'success': False,
            'message': message,
            'error_code': error_code
        }
        return jsonify(response), status_code

    @staticmethod
    def paginated_response(data, page, limit, total):
        response = {
            'success': True,
            'data': data,
            'pagination': {
                'page': page,
                'limit': limit,
                'total': total,
                'total_pages': (total + limit - 1) // limit
            }
        }
        return jsonify(response)
```

## Basic Concurrency

### 1. Threading
```python
import threading
import time
from queue import Queue

class ThreadSafeCounter:
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()

    def increment(self):
        with self._lock:
            self._value += 1

    def get_value(self):
        with self._lock:
            return self._value

class WorkerThread(threading.Thread):
    def __init__(self, task_queue, result_queue):
        super().__init__()
        self.task_queue = task_queue
        self.result_queue = result_queue

    def run(self):
        while True:
            task = self.task_queue.get()
            if task is None:
                break

            # Process task
            result = self.process_task(task)
            self.result_queue.put(result)
            self.task_queue.task_done()

    def process_task(self, task):
        # Simulate work
        time.sleep(1)
        return f"Processed: {task}"

# Usage
task_queue = Queue()
result_queue = Queue()

# Create worker threads
workers = []
for i in range(3):
    worker = WorkerThread(task_queue, result_queue)
    worker.start()
    workers.append(worker)

# Add tasks
for i in range(10):
    task_queue.put(f"Task {i}")

# Wait for completion
task_queue.join()

# Stop workers
for _ in workers:
    task_queue.put(None)
for worker in workers:
    worker.join()
```

### 2. Producer-Consumer Pattern
```python
import threading
import time
import random
from queue import Queue

class Producer(threading.Thread):
    def __init__(self, queue, name):
        super().__init__()
        self.queue = queue
        self.name = name

    def run(self):
        for i in range(5):
            item = f"{self.name}-Item-{i}"
            self.queue.put(item)
            print(f"Producer {self.name} produced {item}")
            time.sleep(random.uniform(0.1, 0.5))

class Consumer(threading.Thread):
    def __init__(self, queue, name):
        super().__init__()
        self.queue = queue
        self.name = name

    def run(self):
        while True:
            try:
                item = self.queue.get(timeout=2)
                print(f"Consumer {self.name} consumed {item}")
                time.sleep(random.uniform(0.1, 0.3))
                self.queue.task_done()
            except:
                break

# Usage
buffer = Queue(maxsize=5)

# Create producers and consumers
producers = [Producer(buffer, f"P{i}") for i in range(2)]
consumers = [Consumer(buffer, f"C{i}") for i in range(3)]

# Start all threads
for p in producers:
    p.start()
for c in consumers:
    c.start()

# Wait for producers to finish
for p in producers:
    p.join()

# Wait for all items to be consumed
buffer.join()
```

## Summary

This covers the fundamental concepts of Low Level System Design:

1. **OOP Principles**: Encapsulation, Inheritance, Polymorphism, Abstraction
2. **SOLID Principles**: Foundation for clean, maintainable code
3. **Design Patterns**: Reusable solutions to common problems
4. **System Components**: MVC, Repository patterns
5. **Data Modeling**: Entity relationships and database design
6. **API Design**: RESTful services and response standards
7. **Basic Concurrency**: Threading and synchronization

These concepts form the building blocks for designing robust, scalable, and maintainable software systems at the component level.