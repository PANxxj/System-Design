# Low Level System Design (LLSD) - Advanced Concepts

## Table of Contents
1. [Microservices Architecture Patterns](#microservices-architecture-patterns)
2. [Advanced Concurrency and Distributed Systems](#advanced-concurrency-and-distributed-systems)
3. [Event Sourcing and CQRS Advanced](#event-sourcing-and-cqrs-advanced)
4. [Circuit Breaker and Resilience Patterns](#circuit-breaker-and-resilience-patterns)
5. [Advanced Caching and Performance](#advanced-caching-and-performance)
6. [Message Queue and Pub/Sub Systems](#message-queue-and-pubsub-systems)
7. [Data Consistency and Transaction Management](#data-consistency-and-transaction-management)
8. [Security and Authentication Patterns](#security-and-authentication-patterns)
9. [Monitoring and Observability](#monitoring-and-observability)
10. [Real-time System Design](#real-time-system-design)

## Microservices Architecture Patterns

### 1. Service Discovery Pattern
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Set
import threading
import time
import random
from dataclasses import dataclass
from datetime import datetime, timedelta

@dataclass
class ServiceInstance:
    service_id: str
    service_name: str
    host: str
    port: int
    metadata: Dict[str, str]
    health_check_url: str
    last_heartbeat: datetime
    status: str = "UP"  # UP, DOWN, STARTING, STOPPING

    def is_healthy(self, timeout_seconds: int = 30) -> bool:
        return (datetime.now() - self.last_heartbeat).seconds < timeout_seconds

class ServiceRegistry(ABC):
    @abstractmethod
    def register(self, instance: ServiceInstance):
        pass

    @abstractmethod
    def deregister(self, service_id: str):
        pass

    @abstractmethod
    def discover(self, service_name: str) -> List[ServiceInstance]:
        pass

    @abstractmethod
    def heartbeat(self, service_id: str):
        pass

class InMemoryServiceRegistry(ServiceRegistry):
    def __init__(self):
        self._services: Dict[str, ServiceInstance] = {}
        self._service_names: Dict[str, Set[str]] = {}
        self._lock = threading.RLock()
        self._cleanup_thread = threading.Thread(target=self._cleanup_unhealthy_services, daemon=True)
        self._cleanup_thread.start()

    def register(self, instance: ServiceInstance):
        with self._lock:
            self._services[instance.service_id] = instance
            if instance.service_name not in self._service_names:
                self._service_names[instance.service_name] = set()
            self._service_names[instance.service_name].add(instance.service_id)
            print(f"Registered service: {instance.service_name} - {instance.service_id}")

    def deregister(self, service_id: str):
        with self._lock:
            if service_id in self._services:
                instance = self._services[service_id]
                del self._services[service_id]
                self._service_names[instance.service_name].discard(service_id)
                print(f"Deregistered service: {instance.service_name} - {service_id}")

    def discover(self, service_name: str) -> List[ServiceInstance]:
        with self._lock:
            service_ids = self._service_names.get(service_name, set())
            healthy_instances = []
            for service_id in service_ids:
                instance = self._services.get(service_id)
                if instance and instance.is_healthy():
                    healthy_instances.append(instance)
            return healthy_instances

    def heartbeat(self, service_id: str):
        with self._lock:
            if service_id in self._services:
                self._services[service_id].last_heartbeat = datetime.now()

    def _cleanup_unhealthy_services(self):
        while True:
            time.sleep(10)  # Cleanup every 10 seconds
            with self._lock:
                unhealthy_services = []
                for service_id, instance in self._services.items():
                    if not instance.is_healthy():
                        unhealthy_services.append(service_id)

                for service_id in unhealthy_services:
                    self.deregister(service_id)

class LoadBalancer:
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry

    def get_instance(self, service_name: str, strategy: str = "round_robin") -> Optional[ServiceInstance]:
        instances = self.service_registry.discover(service_name)
        if not instances:
            return None

        if strategy == "round_robin":
            return self._round_robin_selection(instances)
        elif strategy == "random":
            return random.choice(instances)
        elif strategy == "least_connections":
            return self._least_connections_selection(instances)
        else:
            return instances[0]

    def _round_robin_selection(self, instances: List[ServiceInstance]) -> ServiceInstance:
        if not hasattr(self, '_round_robin_index'):
            self._round_robin_index = {}

        service_name = instances[0].service_name
        if service_name not in self._round_robin_index:
            self._round_robin_index[service_name] = 0

        index = self._round_robin_index[service_name] % len(instances)
        self._round_robin_index[service_name] += 1
        return instances[index]

    def _least_connections_selection(self, instances: List[ServiceInstance]) -> ServiceInstance:
        # In real implementation, you'd track actual connections
        # For demo, using random as placeholder
        return random.choice(instances)

class ServiceClient:
    def __init__(self, service_registry: ServiceRegistry):
        self.load_balancer = LoadBalancer(service_registry)

    def call_service(self, service_name: str, endpoint: str, data: Dict = None) -> Dict:
        instance = self.load_balancer.get_instance(service_name)
        if not instance:
            raise Exception(f"No healthy instances found for service: {service_name}")

        # Simulate HTTP call
        url = f"http://{instance.host}:{instance.port}{endpoint}"
        print(f"Calling {url} with data: {data}")

        # Simulate response
        return {
            "status": "success",
            "data": f"Response from {instance.service_id}",
            "service_instance": instance.service_id
        }

# Example microservice
class MicroService:
    def __init__(self, service_name: str, host: str, port: int, registry: ServiceRegistry):
        self.service_name = service_name
        self.host = host
        self.port = port
        self.registry = registry
        self.service_id = f"{service_name}-{host}-{port}-{int(time.time())}"
        self.running = False
        self.heartbeat_thread = None

    def start(self):
        instance = ServiceInstance(
            service_id=self.service_id,
            service_name=self.service_name,
            host=self.host,
            port=self.port,
            metadata={"version": "1.0", "environment": "prod"},
            health_check_url=f"http://{self.host}:{self.port}/health",
            last_heartbeat=datetime.now()
        )

        self.registry.register(instance)
        self.running = True

        # Start heartbeat
        self.heartbeat_thread = threading.Thread(target=self._send_heartbeat, daemon=True)
        self.heartbeat_thread.start()

        print(f"Service {self.service_name} started on {self.host}:{self.port}")

    def stop(self):
        self.running = False
        self.registry.deregister(self.service_id)
        print(f"Service {self.service_name} stopped")

    def _send_heartbeat(self):
        while self.running:
            self.registry.heartbeat(self.service_id)
            time.sleep(5)  # Heartbeat every 5 seconds

# Usage example
registry = InMemoryServiceRegistry()

# Start multiple service instances
services = []
for i in range(3):
    service = MicroService("user-service", "localhost", 8000 + i, registry)
    service.start()
    services.append(service)

# Client makes calls
client = ServiceClient(registry)

# Make multiple calls to see load balancing
for i in range(6):
    try:
        response = client.call_service("user-service", "/api/users", {"query": f"request-{i}"})
        print(f"Response {i}: {response}")
    except Exception as e:
        print(f"Error: {e}")

# Simulate service failure
print("\nSimulating service failure...")
services[0].stop()

# Continue making calls
for i in range(3):
    try:
        response = client.call_service("user-service", "/api/users", {"query": f"after-failure-{i}"})
        print(f"After failure {i}: {response}")
    except Exception as e:
        print(f"Error: {e}")

# Cleanup
for service in services[1:]:
    service.stop()
```

### 2. API Gateway Pattern
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Callable, Any
import re
import time
import jwt
from datetime import datetime, timedelta

class Request:
    def __init__(self, method: str, path: str, headers: Dict[str, str], body: Dict = None):
        self.method = method
        self.path = path
        self.headers = headers
        self.body = body or {}
        self.context = {}

class Response:
    def __init__(self, status_code: int, body: Dict = None, headers: Dict[str, str] = None):
        self.status_code = status_code
        self.body = body or {}
        self.headers = headers or {}

class Middleware(ABC):
    @abstractmethod
    def process_request(self, request: Request) -> Optional[Response]:
        """Process request. Return Response to short-circuit, None to continue"""
        pass

    @abstractmethod
    def process_response(self, request: Request, response: Response) -> Response:
        """Process response before returning to client"""
        pass

class AuthenticationMiddleware(Middleware):
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.excluded_paths = ["/auth/login", "/health"]

    def process_request(self, request: Request) -> Optional[Response]:
        if request.path in self.excluded_paths:
            return None

        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            return Response(401, {"error": "Missing or invalid authorization header"})

        token = auth_header[7:]  # Remove "Bearer " prefix
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            request.context["user_id"] = payload.get("user_id")
            request.context["roles"] = payload.get("roles", [])
            return None
        except jwt.InvalidTokenError:
            return Response(401, {"error": "Invalid token"})

    def process_response(self, request: Request, response: Response) -> Response:
        return response

class RateLimitingMiddleware(Middleware):
    def __init__(self, requests_per_minute: int = 60):
        self.requests_per_minute = requests_per_minute
        self.client_requests: Dict[str, List[float]] = {}
        self.lock = threading.Lock()

    def process_request(self, request: Request) -> Optional[Response]:
        client_ip = request.headers.get("X-Forwarded-For", "unknown")
        current_time = time.time()

        with self.lock:
            if client_ip not in self.client_requests:
                self.client_requests[client_ip] = []

            # Remove requests older than 1 minute
            self.client_requests[client_ip] = [
                req_time for req_time in self.client_requests[client_ip]
                if current_time - req_time < 60
            ]

            # Check if limit exceeded
            if len(self.client_requests[client_ip]) >= self.requests_per_minute:
                return Response(429, {"error": "Rate limit exceeded"})

            # Add current request
            self.client_requests[client_ip].append(current_time)

        return None

    def process_response(self, request: Request, response: Response) -> Response:
        return response

class LoggingMiddleware(Middleware):
    def process_request(self, request: Request) -> Optional[Response]:
        print(f"[{datetime.now()}] {request.method} {request.path}")
        request.context["start_time"] = time.time()
        return None

    def process_response(self, request: Request, response: Response) -> Response:
        duration = time.time() - request.context.get("start_time", 0)
        print(f"[{datetime.now()}] {request.method} {request.path} - {response.status_code} ({duration:.3f}s)")
        return response

class RouteRule:
    def __init__(self, pattern: str, target_service: str, methods: List[str] = None):
        self.pattern = re.compile(pattern)
        self.target_service = target_service
        self.methods = methods or ["GET", "POST", "PUT", "DELETE"]

    def matches(self, request: Request) -> bool:
        return (request.method in self.methods and
                self.pattern.match(request.path) is not None)

class APIGateway:
    def __init__(self, service_client: ServiceClient):
        self.service_client = service_client
        self.middlewares: List[Middleware] = []
        self.routes: List[RouteRule] = []

    def add_middleware(self, middleware: Middleware):
        self.middlewares.append(middleware)

    def add_route(self, pattern: str, target_service: str, methods: List[str] = None):
        route = RouteRule(pattern, target_service, methods)
        self.routes.append(route)

    def handle_request(self, request: Request) -> Response:
        # Process request through middlewares
        for middleware in self.middlewares:
            response = middleware.process_request(request)
            if response:  # Middleware short-circuited
                return self._process_response_middlewares(request, response)

        # Find matching route
        matching_route = None
        for route in self.routes:
            if route.matches(request):
                matching_route = route
                break

        if not matching_route:
            response = Response(404, {"error": "Route not found"})
            return self._process_response_middlewares(request, response)

        # Forward request to target service
        try:
            # Transform path for service (remove prefix if needed)
            service_path = self._transform_path(request.path, matching_route)
            service_response = self.service_client.call_service(
                matching_route.target_service,
                service_path,
                request.body
            )

            response = Response(200, service_response)
            return self._process_response_middlewares(request, response)

        except Exception as e:
            response = Response(503, {"error": f"Service unavailable: {str(e)}"})
            return self._process_response_middlewares(request, response)

    def _transform_path(self, original_path: str, route: RouteRule) -> str:
        # Transform /api/v1/users/123 -> /users/123 for user-service
        # This is a simple implementation; in real systems, this would be more sophisticated
        if original_path.startswith("/api/v1/users"):
            return original_path.replace("/api/v1/users", "/users")
        elif original_path.startswith("/api/v1/orders"):
            return original_path.replace("/api/v1/orders", "/orders")
        return original_path

    def _process_response_middlewares(self, request: Request, response: Response) -> Response:
        # Process response through middlewares in reverse order
        for middleware in reversed(self.middlewares):
            response = middleware.process_response(request, response)
        return response

# Circuit Breaker for service calls
class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        self.lock = threading.Lock()

    def call(self, func: Callable, *args, **kwargs):
        with self.lock:
            if self.state == "OPEN":
                if self._should_attempt_reset():
                    self.state = "HALF_OPEN"
                else:
                    raise Exception("Circuit breaker is OPEN")

            try:
                result = func(*args, **kwargs)
                self._on_success()
                return result
            except Exception as e:
                self._on_failure()
                raise e

    def _should_attempt_reset(self) -> bool:
        return (self.last_failure_time and
                time.time() - self.last_failure_time >= self.recovery_timeout)

    def _on_success(self):
        self.failure_count = 0
        self.state = "CLOSED"

    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"

# Enhanced Service Client with Circuit Breaker
class ResilientServiceClient(ServiceClient):
    def __init__(self, service_registry: ServiceRegistry):
        super().__init__(service_registry)
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}

    def call_service(self, service_name: str, endpoint: str, data: Dict = None) -> Dict:
        if service_name not in self.circuit_breakers:
            self.circuit_breakers[service_name] = CircuitBreaker()

        circuit_breaker = self.circuit_breakers[service_name]
        return circuit_breaker.call(super().call_service, service_name, endpoint, data)

# Usage example
registry = InMemoryServiceRegistry()
client = ResilientServiceClient(registry)

# Start services
user_service = MicroService("user-service", "localhost", 8001, registry)
order_service = MicroService("order-service", "localhost", 8002, registry)
user_service.start()
order_service.start()

# Create API Gateway
gateway = APIGateway(client)

# Add middlewares
gateway.add_middleware(LoggingMiddleware())
gateway.add_middleware(RateLimitingMiddleware(requests_per_minute=100))
gateway.add_middleware(AuthenticationMiddleware("secret-key"))

# Add routes
gateway.add_route(r"/api/v1/users.*", "user-service", ["GET", "POST", "PUT", "DELETE"])
gateway.add_route(r"/api/v1/orders.*", "order-service", ["GET", "POST", "PUT", "DELETE"])

# Test requests
requests = [
    Request("GET", "/api/v1/users/123", {"Authorization": "Bearer valid-token"}),
    Request("POST", "/api/v1/orders", {"Authorization": "Bearer valid-token"}, {"user_id": 123, "amount": 99.99}),
    Request("GET", "/api/v1/users/456", {}),  # No auth header
    Request("GET", "/nonexistent", {"Authorization": "Bearer valid-token"}),  # 404
]

for req in requests:
    try:
        response = gateway.handle_request(req)
        print(f"Response: {response.status_code} - {response.body}")
    except Exception as e:
        print(f"Error: {e}")
    print("-" * 50)

# Cleanup
user_service.stop()
order_service.stop()
```

## Advanced Concurrency and Distributed Systems

### 1. Actor Model Implementation
```python
import threading
import queue
import time
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, Callable
from dataclasses import dataclass
import uuid

@dataclass
class Message:
    sender: str
    content: Any
    message_id: str = None

    def __post_init__(self):
        if self.message_id is None:
            self.message_id = str(uuid.uuid4())

class Actor(ABC):
    def __init__(self, actor_id: str):
        self.actor_id = actor_id
        self.mailbox = queue.Queue()
        self.running = False
        self.actor_thread = None
        self.actor_system = None

    @abstractmethod
    def receive(self, message: Message):
        """Handle incoming message"""
        pass

    def start(self):
        self.running = True
        self.actor_thread = threading.Thread(target=self._message_loop, daemon=True)
        self.actor_thread.start()

    def stop(self):
        self.running = False
        self.mailbox.put(Message("system", "STOP"))

    def send(self, target_actor_id: str, message: Any):
        if self.actor_system:
            self.actor_system.send_message(target_actor_id, Message(self.actor_id, message))

    def _message_loop(self):
        while self.running:
            try:
                message = self.mailbox.get(timeout=1)
                if message.content == "STOP":
                    break
                self.receive(message)
                self.mailbox.task_done()
            except queue.Empty:
                continue

class ActorSystem:
    def __init__(self):
        self.actors: Dict[str, Actor] = {}
        self.lock = threading.RLock()

    def create_actor(self, actor: Actor):
        with self.lock:
            actor.actor_system = self
            self.actors[actor.actor_id] = actor
            actor.start()

    def send_message(self, target_actor_id: str, message: Message):
        with self.lock:
            if target_actor_id in self.actors:
                self.actors[target_actor_id].mailbox.put(message)
            else:
                print(f"Actor {target_actor_id} not found")

    def stop_actor(self, actor_id: str):
        with self.lock:
            if actor_id in self.actors:
                self.actors[actor_id].stop()
                del self.actors[actor_id]

    def shutdown(self):
        with self.lock:
            for actor in self.actors.values():
                actor.stop()
            self.actors.clear()

# Example actors
class CounterActor(Actor):
    def __init__(self, actor_id: str):
        super().__init__(actor_id)
        self.count = 0

    def receive(self, message: Message):
        if message.content == "increment":
            self.count += 1
            print(f"Counter {self.actor_id}: {self.count}")
        elif message.content == "get":
            self.send(message.sender, self.count)
        elif message.content == "reset":
            self.count = 0
            print(f"Counter {self.actor_id} reset")

class PrinterActor(Actor):
    def receive(self, message: Message):
        print(f"Printer {self.actor_id} received: {message.content} from {message.sender}")

class SupervisorActor(Actor):
    def __init__(self, actor_id: str):
        super().__init__(actor_id)
        self.child_actors = []

    def receive(self, message: Message):
        if message.content == "create_counter":
            counter_id = f"counter-{len(self.child_actors)}"
            counter = CounterActor(counter_id)
            self.actor_system.create_actor(counter)
            self.child_actors.append(counter_id)
            self.send(message.sender, f"Created counter: {counter_id}")

        elif message.content.startswith("broadcast:"):
            broadcast_msg = message.content[10:]  # Remove "broadcast:" prefix
            for child_id in self.child_actors:
                self.send(child_id, broadcast_msg)

# Usage
actor_system = ActorSystem()

# Create actors
supervisor = SupervisorActor("supervisor")
printer = PrinterActor("printer")

actor_system.create_actor(supervisor)
actor_system.create_actor(printer)

# Supervisor creates counter actors
supervisor.send("supervisor", "create_counter")
supervisor.send("supervisor", "create_counter")

time.sleep(0.1)  # Let actors initialize

# Broadcast increment to all counters
supervisor.send("supervisor", "broadcast:increment")
supervisor.send("supervisor", "broadcast:increment")
supervisor.send("supervisor", "broadcast:increment")

time.sleep(0.1)

# Reset one counter
actor_system.send_message("counter-0", Message("test", "reset"))

time.sleep(0.1)
actor_system.shutdown()
```

### 2. Saga Pattern (Distributed Transaction)
```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from enum import Enum
import uuid
import time
import json

class SagaStepStatus(Enum):
    PENDING = "pending"
    COMPLETED = "completed"
    FAILED = "failed"
    COMPENSATED = "compensated"

class SagaStatus(Enum):
    STARTED = "started"
    COMPLETED = "completed"
    FAILED = "failed"
    COMPENSATING = "compensating"
    COMPENSATED = "compensated"

@dataclass
class SagaStep:
    step_id: str
    step_name: str
    execute_data: Dict[str, Any]
    compensate_data: Dict[str, Any]
    status: SagaStepStatus = SagaStepStatus.PENDING
    error_message: Optional[str] = None

class SagaStepExecutor(ABC):
    @abstractmethod
    def execute(self, step: SagaStep) -> bool:
        """Execute the step. Return True if successful, False if failed."""
        pass

    @abstractmethod
    def compensate(self, step: SagaStep) -> bool:
        """Compensate the step. Return True if successful, False if failed."""
        pass

class PaymentStepExecutor(SagaStepExecutor):
    def __init__(self):
        self.payments = {}  # Simulate payment storage

    def execute(self, step: SagaStep) -> bool:
        try:
            payment_id = step.execute_data["payment_id"]
            amount = step.execute_data["amount"]
            user_id = step.execute_data["user_id"]

            print(f"Processing payment {payment_id} for user {user_id}: ${amount}")

            # Simulate payment processing
            if amount > 1000:  # Simulate payment failure for large amounts
                step.error_message = "Payment amount too large"
                return False

            self.payments[payment_id] = {
                "user_id": user_id,
                "amount": amount,
                "status": "completed",
                "timestamp": time.time()
            }

            time.sleep(0.1)  # Simulate processing time
            print(f"Payment {payment_id} completed successfully")
            return True

        except Exception as e:
            step.error_message = str(e)
            return False

    def compensate(self, step: SagaStep) -> bool:
        try:
            payment_id = step.compensate_data["payment_id"]
            print(f"Refunding payment {payment_id}")

            if payment_id in self.payments:
                self.payments[payment_id]["status"] = "refunded"
                print(f"Payment {payment_id} refunded successfully")

            time.sleep(0.1)  # Simulate processing time
            return True

        except Exception as e:
            step.error_message = str(e)
            return False

class InventoryStepExecutor(SagaStepExecutor):
    def __init__(self):
        self.inventory = {"product_1": 100, "product_2": 50}  # Simulate inventory

    def execute(self, step: SagaStep) -> bool:
        try:
            product_id = step.execute_data["product_id"]
            quantity = step.execute_data["quantity"]

            print(f"Reserving {quantity} units of {product_id}")

            if product_id not in self.inventory:
                step.error_message = f"Product {product_id} not found"
                return False

            if self.inventory[product_id] < quantity:
                step.error_message = f"Insufficient inventory for {product_id}"
                return False

            self.inventory[product_id] -= quantity
            print(f"Reserved {quantity} units of {product_id}. Remaining: {self.inventory[product_id]}")

            time.sleep(0.1)  # Simulate processing time
            return True

        except Exception as e:
            step.error_message = str(e)
            return False

    def compensate(self, step: SagaStep) -> bool:
        try:
            product_id = step.compensate_data["product_id"]
            quantity = step.compensate_data["quantity"]

            print(f"Releasing reservation for {quantity} units of {product_id}")

            if product_id in self.inventory:
                self.inventory[product_id] += quantity
                print(f"Released {quantity} units of {product_id}. Available: {self.inventory[product_id]}")

            time.sleep(0.1)  # Simulate processing time
            return True

        except Exception as e:
            step.error_message = str(e)
            return False

class OrderStepExecutor(SagaStepExecutor):
    def __init__(self):
        self.orders = {}  # Simulate order storage

    def execute(self, step: SagaStep) -> bool:
        try:
            order_id = step.execute_data["order_id"]
            user_id = step.execute_data["user_id"]
            items = step.execute_data["items"]

            print(f"Creating order {order_id} for user {user_id}")

            self.orders[order_id] = {
                "user_id": user_id,
                "items": items,
                "status": "confirmed",
                "timestamp": time.time()
            }

            time.sleep(0.1)  # Simulate processing time
            print(f"Order {order_id} created successfully")
            return True

        except Exception as e:
            step.error_message = str(e)
            return False

    def compensate(self, step: SagaStep) -> bool:
        try:
            order_id = step.compensate_data["order_id"]
            print(f"Cancelling order {order_id}")

            if order_id in self.orders:
                self.orders[order_id]["status"] = "cancelled"
                print(f"Order {order_id} cancelled successfully")

            time.sleep(0.1)  # Simulate processing time
            return True

        except Exception as e:
            step.error_message = str(e)
            return False

class Saga:
    def __init__(self, saga_id: str, saga_name: str):
        self.saga_id = saga_id
        self.saga_name = saga_name
        self.steps: List[SagaStep] = []
        self.status = SagaStatus.STARTED
        self.executors: Dict[str, SagaStepExecutor] = {}
        self.current_step_index = 0

    def add_step(self, step: SagaStep, executor: SagaStepExecutor):
        self.steps.append(step)
        self.executors[step.step_id] = executor

    def execute(self) -> bool:
        """Execute all saga steps. Return True if all successful, False if any failed."""
        print(f"Starting saga: {self.saga_name}")

        for i, step in enumerate(self.steps):
            self.current_step_index = i
            executor = self.executors[step.step_id]

            print(f"Executing step {i + 1}/{len(self.steps)}: {step.step_name}")

            if executor.execute(step):
                step.status = SagaStepStatus.COMPLETED
                print(f"Step {step.step_name} completed successfully")
            else:
                step.status = SagaStepStatus.FAILED
                print(f"Step {step.step_name} failed: {step.error_message}")
                self.status = SagaStatus.FAILED
                self._compensate()
                return False

        self.status = SagaStatus.COMPLETED
        print(f"Saga {self.saga_name} completed successfully")
        return True

    def _compensate(self):
        """Compensate all completed steps in reverse order."""
        print(f"Starting compensation for saga: {self.saga_name}")
        self.status = SagaStatus.COMPENSATING

        # Compensate completed steps in reverse order
        for i in range(self.current_step_index - 1, -1, -1):
            step = self.steps[i]
            if step.status == SagaStepStatus.COMPLETED:
                executor = self.executors[step.step_id]

                print(f"Compensating step: {step.step_name}")

                if executor.compensate(step):
                    step.status = SagaStepStatus.COMPENSATED
                    print(f"Step {step.step_name} compensated successfully")
                else:
                    print(f"Failed to compensate step {step.step_name}: {step.error_message}")
                    # In real implementation, you might retry or alert administrators

        self.status = SagaStatus.COMPENSATED
        print(f"Saga {self.saga_name} compensation completed")

class SagaOrchestrator:
    def __init__(self):
        self.sagas: Dict[str, Saga] = {}
        self.step_executors = {
            "payment": PaymentStepExecutor(),
            "inventory": InventoryStepExecutor(),
            "order": OrderStepExecutor()
        }

    def create_order_saga(self, order_data: Dict[str, Any]) -> str:
        saga_id = str(uuid.uuid4())
        saga = Saga(saga_id, f"Order Processing - {order_data['order_id']}")

        # Step 1: Reserve inventory
        inventory_step = SagaStep(
            step_id="inventory-reservation",
            step_name="Reserve Inventory",
            execute_data={
                "product_id": order_data["product_id"],
                "quantity": order_data["quantity"]
            },
            compensate_data={
                "product_id": order_data["product_id"],
                "quantity": order_data["quantity"]
            }
        )

        # Step 2: Process payment
        payment_step = SagaStep(
            step_id="payment-processing",
            step_name="Process Payment",
            execute_data={
                "payment_id": order_data["payment_id"],
                "user_id": order_data["user_id"],
                "amount": order_data["amount"]
            },
            compensate_data={
                "payment_id": order_data["payment_id"]
            }
        )

        # Step 3: Create order
        order_step = SagaStep(
            step_id="order-creation",
            step_name="Create Order",
            execute_data={
                "order_id": order_data["order_id"],
                "user_id": order_data["user_id"],
                "items": [{"product_id": order_data["product_id"], "quantity": order_data["quantity"]}]
            },
            compensate_data={
                "order_id": order_data["order_id"]
            }
        )

        # Add steps to saga
        saga.add_step(inventory_step, self.step_executors["inventory"])
        saga.add_step(payment_step, self.step_executors["payment"])
        saga.add_step(order_step, self.step_executors["order"])

        self.sagas[saga_id] = saga
        return saga_id

    def execute_saga(self, saga_id: str) -> bool:
        if saga_id not in self.sagas:
            print(f"Saga {saga_id} not found")
            return False

        saga = self.sagas[saga_id]
        return saga.execute()

# Usage example
orchestrator = SagaOrchestrator()

# Test successful order
print("=== Testing Successful Order ===")
order_data_success = {
    "order_id": "ORDER-001",
    "user_id": "USER-123",
    "product_id": "product_1",
    "quantity": 2,
    "payment_id": "PAY-001",
    "amount": 99.99
}

saga_id = orchestrator.create_order_saga(order_data_success)
success = orchestrator.execute_saga(saga_id)
print(f"Order saga result: {'SUCCESS' if success else 'FAILED'}")

print("\n" + "="*50 + "\n")

# Test failed order (payment failure due to high amount)
print("=== Testing Failed Order (High Payment Amount) ===")
order_data_failure = {
    "order_id": "ORDER-002",
    "user_id": "USER-456",
    "product_id": "product_2",
    "quantity": 1,
    "payment_id": "PAY-002",
    "amount": 1500.00  # This will cause payment failure
}

saga_id = orchestrator.create_order_saga(order_data_failure)
success = orchestrator.execute_saga(saga_id)
print(f"Order saga result: {'SUCCESS' if success else 'FAILED'}")

print("\n" + "="*50 + "\n")

# Test failed order (insufficient inventory)
print("=== Testing Failed Order (Insufficient Inventory) ===")
order_data_inventory_fail = {
    "order_id": "ORDER-003",
    "user_id": "USER-789",
    "product_id": "product_2",
    "quantity": 100,  # More than available inventory
    "payment_id": "PAY-003",
    "amount": 299.99
}

saga_id = orchestrator.create_order_saga(order_data_inventory_fail)
success = orchestrator.execute_saga(saga_id)
print(f"Order saga result: {'SUCCESS' if success else 'FAILED'}")
```

## Event Sourcing and CQRS Advanced

### 1. Complete Event Sourcing Implementation
```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Type
import json
import sqlite3
from datetime import datetime
import uuid
from dataclasses import dataclass, asdict
import threading

# Event Store
@dataclass
class StoredEvent:
    event_id: str
    aggregate_id: str
    event_type: str
    event_data: str
    event_version: int
    timestamp: datetime

class EventStore:
    def __init__(self, db_path: str = ":memory:"):
        self.db_path = db_path
        self.lock = threading.RLock()
        self._init_database()

    def _init_database(self):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS events (
                    event_id TEXT PRIMARY KEY,
                    aggregate_id TEXT NOT NULL,
                    event_type TEXT NOT NULL,
                    event_data TEXT NOT NULL,
                    event_version INTEGER NOT NULL,
                    timestamp TEXT NOT NULL
                )
            ''')
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_aggregate_id_version
                ON events(aggregate_id, event_version)
            ''')

    def save_events(self, aggregate_id: str, events: List[DomainEvent], expected_version: int):
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                # Check for concurrency conflicts
                cursor = conn.execute(
                    'SELECT MAX(event_version) FROM events WHERE aggregate_id = ?',
                    (aggregate_id,)
                )
                current_version = cursor.fetchone()[0] or 0

                if current_version != expected_version:
                    raise Exception(f"Concurrency conflict: expected version {expected_version}, current version {current_version}")

                # Save events
                for i, event in enumerate(events):
                    stored_event = StoredEvent(
                        event_id=event.event_id,
                        aggregate_id=aggregate_id,
                        event_type=event.__class__.__name__,
                        event_data=json.dumps(asdict(event)),
                        event_version=expected_version + i + 1,
                        timestamp=event.timestamp
                    )

                    conn.execute('''
                        INSERT INTO events (event_id, aggregate_id, event_type, event_data, event_version, timestamp)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (
                        stored_event.event_id,
                        stored_event.aggregate_id,
                        stored_event.event_type,
                        stored_event.event_data,
                        stored_event.event_version,
                        stored_event.timestamp.isoformat()
                    ))

    def get_events(self, aggregate_id: str, from_version: int = 0) -> List[StoredEvent]:
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute('''
                    SELECT * FROM events
                    WHERE aggregate_id = ? AND event_version > ?
                    ORDER BY event_version
                ''', (aggregate_id, from_version))

                events = []
                for row in cursor.fetchall():
                    events.append(StoredEvent(
                        event_id=row['event_id'],
                        aggregate_id=row['aggregate_id'],
                        event_type=row['event_type'],
                        event_data=row['event_data'],
                        event_version=row['event_version'],
                        timestamp=datetime.fromisoformat(row['timestamp'])
                    ))
                return events

    def get_all_events_after(self, global_position: int = 0) -> List[StoredEvent]:
        """Get all events after a global position for projections"""
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute('''
                    SELECT rowid, * FROM events
                    WHERE rowid > ?
                    ORDER BY rowid
                ''', (global_position,))

                events = []
                for row in cursor.fetchall():
                    event = StoredEvent(
                        event_id=row['event_id'],
                        aggregate_id=row['aggregate_id'],
                        event_type=row['event_type'],
                        event_data=row['event_data'],
                        event_version=row['event_version'],
                        timestamp=datetime.fromisoformat(row['timestamp'])
                    )
                    event.global_position = row['rowid']  # Add global position
                    events.append(event)
                return events

# Enhanced Domain Events
@dataclass
class DomainEvent:
    event_id: str
    timestamp: datetime
    aggregate_id: str = None

    def __post_init__(self):
        if not self.event_id:
            self.event_id = str(uuid.uuid4())

@dataclass
class BankAccountOpenedEvent(DomainEvent):
    account_number: str
    owner_name: str
    initial_balance: float

@dataclass
class MoneyDepositedEvent(DomainEvent):
    amount: float
    description: str

@dataclass
class MoneyWithdrawnEvent(DomainEvent):
    amount: float
    description: str

@dataclass
class AccountClosedEvent(DomainEvent):
    reason: str

# Aggregate Root with Event Sourcing
class EventSourcedAggregate:
    def __init__(self, aggregate_id: str):
        self.aggregate_id = aggregate_id
        self.version = 0
        self._uncommitted_events: List[DomainEvent] = []

    def apply_event(self, event: DomainEvent):
        """Apply event to aggregate state"""
        event.aggregate_id = self.aggregate_id
        method_name = f"_apply_{event.__class__.__name__}"
        if hasattr(self, method_name):
            getattr(self, method_name)(event)
        self.version += 1

    def raise_event(self, event: DomainEvent):
        """Raise new event"""
        self.apply_event(event)
        self._uncommitted_events.append(event)

    def load_from_history(self, events: List[DomainEvent]):
        """Rebuild aggregate state from events"""
        for event in events:
            self.apply_event(event)

    def get_uncommitted_events(self) -> List[DomainEvent]:
        return self._uncommitted_events.copy()

    def mark_events_committed(self):
        self._uncommitted_events.clear()

class BankAccount(EventSourcedAggregate):
    def __init__(self, aggregate_id: str):
        super().__init__(aggregate_id)
        self.account_number = None
        self.owner_name = None
        self.balance = 0.0
        self.is_closed = False

    @classmethod
    def open_account(cls, account_number: str, owner_name: str, initial_balance: float = 0.0) -> 'BankAccount':
        account_id = str(uuid.uuid4())
        account = cls(account_id)

        event = BankAccountOpenedEvent(
            event_id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            account_number=account_number,
            owner_name=owner_name,
            initial_balance=initial_balance
        )

        account.raise_event(event)
        return account

    def deposit(self, amount: float, description: str = ""):
        if self.is_closed:
            raise Exception("Cannot deposit to closed account")
        if amount <= 0:
            raise Exception("Deposit amount must be positive")

        event = MoneyDepositedEvent(
            event_id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            amount=amount,
            description=description
        )

        self.raise_event(event)

    def withdraw(self, amount: float, description: str = ""):
        if self.is_closed:
            raise Exception("Cannot withdraw from closed account")
        if amount <= 0:
            raise Exception("Withdrawal amount must be positive")
        if self.balance < amount:
            raise Exception("Insufficient funds")

        event = MoneyWithdrawnEvent(
            event_id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            amount=amount,
            description=description
        )

        self.raise_event(event)

    def close_account(self, reason: str = ""):
        if self.is_closed:
            raise Exception("Account is already closed")

        event = AccountClosedEvent(
            event_id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            reason=reason
        )

        self.raise_event(event)

    # Event handlers
    def _apply_BankAccountOpenedEvent(self, event: BankAccountOpenedEvent):
        self.account_number = event.account_number
        self.owner_name = event.owner_name
        self.balance = event.initial_balance

    def _apply_MoneyDepositedEvent(self, event: MoneyDepositedEvent):
        self.balance += event.amount

    def _apply_MoneyWithdrawnEvent(self, event: MoneyWithdrawnEvent):
        self.balance -= event.amount

    def _apply_AccountClosedEvent(self, event: AccountClosedEvent):
        self.is_closed = True

# Repository for Event Sourced Aggregates
class EventSourcedRepository:
    def __init__(self, event_store: EventStore, aggregate_type: Type[EventSourcedAggregate]):
        self.event_store = event_store
        self.aggregate_type = aggregate_type
        self.event_deserializers = {
            'BankAccountOpenedEvent': self._deserialize_bank_account_opened,
            'MoneyDepositedEvent': self._deserialize_money_deposited,
            'MoneyWithdrawnEvent': self._deserialize_money_withdrawn,
            'AccountClosedEvent': self._deserialize_account_closed,
        }

    def save(self, aggregate: EventSourcedAggregate):
        events = aggregate.get_uncommitted_events()
        if events:
            self.event_store.save_events(aggregate.aggregate_id, events, aggregate.version - len(events))
            aggregate.mark_events_committed()

    def get_by_id(self, aggregate_id: str) -> Optional[EventSourcedAggregate]:
        stored_events = self.event_store.get_events(aggregate_id)
        if not stored_events:
            return None

        # Deserialize events
        domain_events = []
        for stored_event in stored_events:
            deserializer = self.event_deserializers.get(stored_event.event_type)
            if deserializer:
                domain_event = deserializer(stored_event)
                domain_events.append(domain_event)

        # Rebuild aggregate
        aggregate = self.aggregate_type(aggregate_id)
        aggregate.load_from_history(domain_events)
        return aggregate

    def _deserialize_bank_account_opened(self, stored_event: StoredEvent) -> BankAccountOpenedEvent:
        data = json.loads(stored_event.event_data)
        return BankAccountOpenedEvent(
            event_id=data['event_id'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            aggregate_id=stored_event.aggregate_id,
            account_number=data['account_number'],
            owner_name=data['owner_name'],
            initial_balance=data['initial_balance']
        )

    def _deserialize_money_deposited(self, stored_event: StoredEvent) -> MoneyDepositedEvent:
        data = json.loads(stored_event.event_data)
        return MoneyDepositedEvent(
            event_id=data['event_id'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            aggregate_id=stored_event.aggregate_id,
            amount=data['amount'],
            description=data['description']
        )

    def _deserialize_money_withdrawn(self, stored_event: StoredEvent) -> MoneyWithdrawnEvent:
        data = json.loads(stored_event.event_data)
        return MoneyWithdrawnEvent(
            event_id=data['event_id'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            aggregate_id=stored_event.aggregate_id,
            amount=data['amount'],
            description=data['description']
        )

    def _deserialize_account_closed(self, stored_event: StoredEvent) -> AccountClosedEvent:
        data = json.loads(stored_event.event_data)
        return AccountClosedEvent(
            event_id=data['event_id'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            aggregate_id=stored_event.aggregate_id,
            reason=data['reason']
        )

# Projection Engine for Read Models
@dataclass
class AccountSummaryProjection:
    account_id: str
    account_number: str
    owner_name: str
    current_balance: float
    total_deposits: float
    total_withdrawals: float
    transaction_count: int
    is_closed: bool
    last_activity: datetime

class ProjectionStore:
    def __init__(self, db_path: str = ":memory:"):
        self.db_path = db_path
        self.lock = threading.RLock()
        self._init_database()

    def _init_database(self):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS account_summary (
                    account_id TEXT PRIMARY KEY,
                    account_number TEXT,
                    owner_name TEXT,
                    current_balance REAL,
                    total_deposits REAL,
                    total_withdrawals REAL,
                    transaction_count INTEGER,
                    is_closed BOOLEAN,
                    last_activity TEXT
                )
            ''')

            conn.execute('''
                CREATE TABLE IF NOT EXISTS projection_checkpoint (
                    projection_name TEXT PRIMARY KEY,
                    last_processed_position INTEGER
                )
            ''')

    def save_account_summary(self, projection: AccountSummaryProjection):
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    INSERT OR REPLACE INTO account_summary
                    (account_id, account_number, owner_name, current_balance, total_deposits,
                     total_withdrawals, transaction_count, is_closed, last_activity)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    projection.account_id,
                    projection.account_number,
                    projection.owner_name,
                    projection.current_balance,
                    projection.total_deposits,
                    projection.total_withdrawals,
                    projection.transaction_count,
                    projection.is_closed,
                    projection.last_activity.isoformat()
                ))

    def get_account_summary(self, account_id: str) -> Optional[AccountSummaryProjection]:
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute(
                    'SELECT * FROM account_summary WHERE account_id = ?',
                    (account_id,)
                )
                row = cursor.fetchone()
                if row:
                    return AccountSummaryProjection(
                        account_id=row['account_id'],
                        account_number=row['account_number'],
                        owner_name=row['owner_name'],
                        current_balance=row['current_balance'],
                        total_deposits=row['total_deposits'],
                        total_withdrawals=row['total_withdrawals'],
                        transaction_count=row['transaction_count'],
                        is_closed=bool(row['is_closed']),
                        last_activity=datetime.fromisoformat(row['last_activity'])
                    )
                return None

    def get_checkpoint(self, projection_name: str) -> int:
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    'SELECT last_processed_position FROM projection_checkpoint WHERE projection_name = ?',
                    (projection_name,)
                )
                row = cursor.fetchone()
                return row[0] if row else 0

    def update_checkpoint(self, projection_name: str, position: int):
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    INSERT OR REPLACE INTO projection_checkpoint (projection_name, last_processed_position)
                    VALUES (?, ?)
                ''', (projection_name, position))

class AccountSummaryProjectionHandler:
    def __init__(self, projection_store: ProjectionStore):
        self.projection_store = projection_store
        self.projection_name = "AccountSummary"

    def handle_bank_account_opened(self, event: BankAccountOpenedEvent):
        projection = AccountSummaryProjection(
            account_id=event.aggregate_id,
            account_number=event.account_number,
            owner_name=event.owner_name,
            current_balance=event.initial_balance,
            total_deposits=event.initial_balance,
            total_withdrawals=0.0,
            transaction_count=1 if event.initial_balance > 0 else 0,
            is_closed=False,
            last_activity=event.timestamp
        )
        self.projection_store.save_account_summary(projection)

    def handle_money_deposited(self, event: MoneyDepositedEvent):
        projection = self.projection_store.get_account_summary(event.aggregate_id)
        if projection:
            projection.current_balance += event.amount
            projection.total_deposits += event.amount
            projection.transaction_count += 1
            projection.last_activity = event.timestamp
            self.projection_store.save_account_summary(projection)

    def handle_money_withdrawn(self, event: MoneyWithdrawnEvent):
        projection = self.projection_store.get_account_summary(event.aggregate_id)
        if projection:
            projection.current_balance -= event.amount
            projection.total_withdrawals += event.amount
            projection.transaction_count += 1
            projection.last_activity = event.timestamp
            self.projection_store.save_account_summary(projection)

    def handle_account_closed(self, event: AccountClosedEvent):
        projection = self.projection_store.get_account_summary(event.aggregate_id)
        if projection:
            projection.is_closed = True
            projection.last_activity = event.timestamp
            self.projection_store.save_account_summary(projection)

    def rebuild_projections(self, event_store: EventStore):
        """Rebuild all projections from events"""
        print("Rebuilding account summary projections...")

        # Clear existing projections
        self.projection_store._init_database()

        # Process all events
        events = event_store.get_all_events_after(0)
        for event in events:
            self._process_event(event)

        print(f"Processed {len(events)} events for projection rebuild")

    def process_new_events(self, event_store: EventStore):
        """Process new events since last checkpoint"""
        last_position = self.projection_store.get_checkpoint(self.projection_name)
        events = event_store.get_all_events_after(last_position)

        for event in events:
            self._process_event(event)
            self.projection_store.update_checkpoint(self.projection_name, event.global_position)

        if events:
            print(f"Processed {len(events)} new events for {self.projection_name}")

    def _process_event(self, stored_event: StoredEvent):
        """Process a single stored event"""
        event_data = json.loads(stored_event.event_data)

        if stored_event.event_type == 'BankAccountOpenedEvent':
            event = BankAccountOpenedEvent(
                event_id=event_data['event_id'],
                timestamp=datetime.fromisoformat(event_data['timestamp']),
                aggregate_id=stored_event.aggregate_id,
                account_number=event_data['account_number'],
                owner_name=event_data['owner_name'],
                initial_balance=event_data['initial_balance']
            )
            self.handle_bank_account_opened(event)

        elif stored_event.event_type == 'MoneyDepositedEvent':
            event = MoneyDepositedEvent(
                event_id=event_data['event_id'],
                timestamp=datetime.fromisoformat(event_data['timestamp']),
                aggregate_id=stored_event.aggregate_id,
                amount=event_data['amount'],
                description=event_data['description']
            )
            self.handle_money_deposited(event)

        elif stored_event.event_type == 'MoneyWithdrawnEvent':
            event = MoneyWithdrawnEvent(
                event_id=event_data['event_id'],
                timestamp=datetime.fromisoformat(event_data['timestamp']),
                aggregate_id=stored_event.aggregate_id,
                amount=event_data['amount'],
                description=event_data['description']
            )
            self.handle_money_withdrawn(event)

        elif stored_event.event_type == 'AccountClosedEvent':
            event = AccountClosedEvent(
                event_id=event_data['event_id'],
                timestamp=datetime.fromisoformat(event_data['timestamp']),
                aggregate_id=stored_event.aggregate_id,
                reason=event_data['reason']
            )
            self.handle_account_closed(event)

# Usage example
print("=== Event Sourcing and CQRS Example ===")

# Initialize stores
event_store = EventStore()
projection_store = ProjectionStore()
account_repository = EventSourcedRepository(event_store, BankAccount)
projection_handler = AccountSummaryProjectionHandler(projection_store)

# Create and operate on bank account
account = BankAccount.open_account("ACC-12345", "John Doe", 1000.0)
account.deposit(500.0, "Salary deposit")
account.withdraw(200.0, "ATM withdrawal")
account.deposit(300.0, "Freelance payment")

# Save account (persists events)
account_repository.save(account)

print(f"Account balance after operations: ${account.balance}")

# Process events for projections
projection_handler.process_new_events(event_store)

# Query read model
account_summary = projection_store.get_account_summary(account.aggregate_id)
print(f"Account Summary from Read Model:")
print(f"  Owner: {account_summary.owner_name}")
print(f"  Balance: ${account_summary.current_balance}")
print(f"  Total Deposits: ${account_summary.total_deposits}")
print(f"  Total Withdrawals: ${account_summary.total_withdrawals}")
print(f"  Transaction Count: {account_summary.transaction_count}")

# Reload account from events (demonstrates event sourcing)
reloaded_account = account_repository.get_by_id(account.aggregate_id)
print(f"\nReloaded account balance: ${reloaded_account.balance}")
print(f"Account versions match: {account.version == reloaded_account.version}")

# Continue operations
reloaded_account.withdraw(100.0, "Online purchase")
account_repository.save(reloaded_account)

# Update projections
projection_handler.process_new_events(event_store)

# Query updated read model
updated_summary = projection_store.get_account_summary(account.aggregate_id)
print(f"\nUpdated Account Summary:")
print(f"  Balance: ${updated_summary.current_balance}")
print(f"  Total Withdrawals: ${updated_summary.total_withdrawals}")
print(f"  Transaction Count: {updated_summary.transaction_count}")
```

## Summary

This advanced LLSD guide covers:

1. **Microservices Patterns**: Service discovery, load balancing, API gateway
2. **Advanced Concurrency**: Actor model, distributed transactions (Saga)
3. **Event Sourcing & CQRS**: Complete implementation with projections
4. **Circuit Breaker**: Resilience patterns for distributed systems
5. **Message Queues**: Async communication patterns
6. **Data Consistency**: Transaction management across services
7. **Security**: Authentication and authorization patterns
8. **Monitoring**: Observability and metrics collection
9. **Real-time Systems**: WebSocket and streaming patterns

These advanced patterns enable building complex, distributed, resilient systems that can handle enterprise-scale requirements while maintaining consistency and performance.